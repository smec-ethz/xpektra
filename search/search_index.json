{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"xpektra: Modular framework for spectral methods <p><code>xpektra</code> is a Python library that provides a modularframework for spectral methods.  <code>xpektra</code> provide fundamental mathematical building blocks which can be used to construct complex spectral methods. It is built on top of JAX and Equinox, making it easy to use spectral methods in a differentiable way.</p>"},{"location":"#license","title":"License","text":"<p><code>xpektra</code> is distributed under the GNU Lesser General Public License v3.0 or later. See <code>COPYING</code> and <code>COPYING.LESSER</code> for the complete terms. \u00a9 2025 ETH Zurich (Mohit Pundir).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular building blocks for spectral methods which can be easily combined to create complex solid mechanics problems.</li> <li>Extensible design allowing users to define their own operators and spaces such as Fourier-Galerkin, Moulinec and Suquet, Displacement-based, etc.</li> <li>Differentiable operations using JAX</li> <li>Implicit differentiation support which allows for computationally efficient Homogenization and Multiscale simulations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.10+.</p> <pre><code>pip install xpektra\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":""},{"location":"basics/","title":"Building Blocks of <code>xpektra</code>","text":"<p>The <code>xpektra</code> library is built on a set of modular, JAX-native components. The core philosophy is to provide a \"toolkit\" that separates the geometry (grids), the calculus (differentiation rules), and the physics (equilibrium constraints).</p> <p>The library is organized into a hierarchy. As a user, you will primarily interact with the <code>SpectralOperator</code>, which acts as a facade for the underlying machinery.</p> <ol> <li><code>TensorFields</code>: The underlying data structures and algebra engine.</li> <li><code>SpectralSpace &amp; Transform</code>: The \"canvas\" that defines the grid and the transform (FFT, DCT).</li> <li><code>Scheme</code>: The \"rulebook\" for how derivatives are calculated.</li> <li><code>ProjectionOperator</code>: The physics engine used to build Green's operators for specific formulations.</li> <li><code>SpectralOperator</code>: The main interface that combines space and scheme to provide high-level operations (<code>grad</code>, <code>div</code>, <code>fft</code>).</li> </ol>"},{"location":"basics/#the-data-tensor-fields","title":"The Data: <code>Tensor Fields</code>","text":"<p>In <code>xpektra</code>, physical quantities like stress, strain, or displacement are represented as JAX arrays. The library enforces a consistent <code>(spatial..., tensor...)</code> memory layout.</p> <p>This means the spatial grid dimensions <code>(N_x, N_y, ...)</code> always come first, followed by the tensor component dimensions <code>(d, d, ...)</code>.</p> <ul> <li><code>Scalar Field (Rank 0)</code> in 2D: <code>(N, N)</code></li> <li><code>Vector Field (Rank 1)</code> in 2D: <code>(N, N, 2)</code></li> <li><code>Tensor Field (Rank 2)</code> in 2D: <code>(N, N, 2, 2)</code></li> </ul> <p><code>xpektra</code> provides a helper function <code>make_field</code> to create fields with the correct shape.</p> <pre><code>from xpektra import make_field\n\n# Create a rank-2 (2x2) tensor field on a 128x128 grid\nstress = make_field(dim=2, N=128, rank=2)\nprint(stress.shape) # Output: (128, 128, 2, 2)\n</code></pre>"},{"location":"basics/#the-foundation-spectralspace-and-transform","title":"The Foundation: <code>SpectralSpace</code> and <code>Transform</code>","text":"<p>The <code>SpectralSpace</code> class defines the geometry of your problem. It holds the physical dimensions, the grid resolution, and the transform strategy (e.g., FFT or DCT) used to move between real and spectral space. We define the transform strategy in the <code>Transform</code> class.</p> <pre><code>from xpektra import SpectralSpace\nfrom xpektra.transform import FFTTransform\n\n# 1. Choose a Transform Strategy\ntransform = FFTTransform(dim=2)\n\n# 2. Define the Space\nspace = SpectralSpace(lengths =(1, 10), shape=(64, 256), transform=transform)\n</code></pre> <p>Non-Square/Non-Cube Grids</p> <p>The <code>SpectralSpace</code> class is defined for rectangular/square grids in 2D and cuboid grids in 3D.</p>"},{"location":"basics/#the-calculus-scheme","title":"The Calculus: <code>Scheme</code>","text":"<p>Discretization is handled by <code>Scheme</code> objects. These define how derivatives are computed. In <code>xpektra</code> we have divided the scheme based on the type of grid and how the differentiation looks in Fourier space. </p> <p>Currently, we support cartersian based schemes with diagonalized differentiation operator in Fourier space.Some of the available schemes include:</p> <ul> <li><code>Fourier</code>: The standard spectral derivative (\\(D_k = i \\xi_k\\)). Accurate but prone to Gibbs ringing.</li> <li><code>CentralDifference</code>: A robust finite difference scheme (\\(D_k = i \\sin(\\xi_k h)/h\\)). Equivalent to Linear Finite Elements; eliminates ringing.</li> <li><code>RotatedDifference</code>: An advanced finite difference scheme (Willot, 2015) offering high stability.</li> </ul> <pre><code>from xpektra.scheme import RotatedDifference\n\n# Create a scheme attached to your space\nscheme = RotatedDifference(space=space)\n</code></pre> <p>Extending to Non-Cartesian grids or non-diagonalized differentiation</p> <p>We are actively working on extending <code>xpektra</code> to support non-Cartesian grids and non-diagonalized differentiation operators. But one can easily implement their own scheme by subclassing the <code>Scheme</code> class as shown in the documentation.</p>"},{"location":"basics/#the-interface-spectraloperator","title":"The Interface: <code>SpectralOperator</code>","text":"<p>The <code>SpectralOperator</code> is the heart of the library. It combines the <code>Space</code> and the <code>Scheme</code> into a single, powerful toolkit.</p> <p>Instead of managing transforms and derivatives manually, you use this operator to perform high-level mathematical operations on your fields.</p> <pre><code>from xpektra.spectral_operator import SpectralOperator\n\n# Initialize the main operator\nop = SpectralOperator(space=space, scheme=scheme)\n\n# --- Calculus Operations ---\ngrad_u = op.grad(u)       # Computes gradient of scalar u\ndiv_v  = op.div(v)        # Computes divergence of vector v\nsym_grad = op.sym_grad(u) # Computes symmetric gradient (strain)\n\n# --- Transform Operations ---\nu_hat = op.forward(u)     # Forward transform (FFT/DCT)\nu_real = op.inverse(u_hat) # Inverse transform\n</code></pre> <p>The <code>SpectralOperator</code> is \"smart\" that means it delegates the math to the specific <code>Scheme</code> you chose, ensuring consistency.</p>"},{"location":"basics/#the-algebra-tensoroperator","title":"The Algebra: <code>TensorOperator</code>","text":"<p>The <code>TensorOperator</code> is the low-level engine handling tensor contractions (dot products, traces) on the grid.</p> <p>While it powers the library internally, you rarely need to instantiate it yourself. The <code>SpectralOperator</code> exposes the most common tensor operations directly for convenience:</p> <pre><code># Dot product (contraction)\nC = op.dot(A, B) \n\n# Double dot product (A : B)\nenergy = op.ddot(sigma, epsilon)\n\n# Transpose\ngrad_u_T = op.trans(grad_u)\n</code></pre> <p>If you need advanced tensor manipulations, the underlying engine is available via <code>op.tensor_op</code>.</p>"},{"location":"basics/#the-physics-projectionoperator","title":"The Physics: <code>ProjectionOperator</code>","text":"<p>For solvers based on the Lippmann-Schwinger equation or Galerkin methods, you need a <code>ProjectionOperator</code>. This component pre-computes the 4th-order Green's operator (\\(\\hat{\\mathbb{\\Gamma}}^0\\) or \\(\\hat{\\mathbb{G}}\\)) in spectral space, which enforces equilibrium constraints.</p> <p>You typically instantiate a specific type of projection based on your formulation:</p>"},{"location":"basics/#galerkin-projection","title":"Galerkin Projection","text":"<p>Used for the material-independent variational formulation (recommended for Newton-Krylov solvers).</p> <pre><code>from xpektra.projection_operator import GalerkinProjection\n\n# Build the operator from your scheme\nprojection = GalerkinProjection(scheme=scheme)\n\n# Apply projection: P(sigma_hat)\nresidual_hat = projection.project(sigma_hat)\n</code></pre> <p>Matrix-free Galerkin Projection</p> <p><code>xpektra</code> implements a matrix-free <code>GalerkinProjection</code> that means the projection is applied without explicitly forming the matrix, which can be memory-intensive for large problems.</p>"},{"location":"basics/#moulinec-suquet-projection","title":"Moulinec-Suquet Projection","text":"<p>Used for the classic fixed-point scheme with a reference material (\\(\\mathbb{C}_0\\)). This Moulinec-Suquet projection is used to solve the Lippmann-Schwinger equation: \\(\\varepsilon^{k+1} = \\bar{E} - \\Gamma^0 * (\\sigma(\\varepsilon^k) - C_0 : \\varepsilon^k)\\).</p> <pre><code>from xpektra.projection_operator import MoulinecSuquetProjection\n\n# Build with reference material properties\nms_proj = MoulinecSuquetProjection(\n    scheme=scheme, \n    lambda0=100.0, \n    mu0=25.0\n)\n</code></pre>"},{"location":"extensibility/","title":"Extensibility: Building Your Own Methods","text":"<p>The modular, \"abstract-or-final\" design of <code>xpektra</code> is not just an internal feature; it's an open invitation for you to extend the library. You can implement entirely new schemes, formulations, or solvers without modifying any of the core <code>xpektra</code> code.</p> <p>The library's abstract classes (<code>Scheme</code>, <code>CartesianScheme</code>, <code>ProjectionOperator</code>) define a clear API \"contract.\" To add new functionality, you simply create a new class that inherits from one of these base classes and provides the required methods.</p> <p>Here are a few examples of how you could extend the library.</p> <p>Implementing a New Discretization <code>Scheme</code></p> <p>Goal: You want to implement a specific finite difference scheme, like the <code>TETRA2</code> method, which is known for its stability.</p> <p>How: You create a new class that inherits from <code>Scheme</code> if it is not cartesian or diagonal, otherwise you inherit from <code>DiagonalScheme</code>. Because the <code>TETRA2</code> logic is complex and non-separable, you would override the entire <code>_compute_gradient_operator</code> method to implement its unique mixing formula.</p> <pre><code>from xpektra.scheme import DiagonalScheme\n\nclass TETRA2(DiagonalScheme):\n    \"\"\"\n    Implements the TETRA2 finite difference scheme by overriding\n    the gradient operator computation.\n    \"\"\"\n    def _compute_gradient_operator(self) -&gt; Array:\n        # 1. Get wavenumber meshes from the base class\n        xi, yi, zi = self._wavenumbers_mesh\n\n        # 2. Implement the private methods for the T1 and T2 operators\n        # D_T1 = self._operator_T1(...)\n        # D_T2 = self._operator_T2(...)\n\n        # 3. Implement the mixing logic\n        # D_mixed = 0.5 * D_T1 + 0.5 * D_T2\n\n        # 4. Stack and return the final operator\n        # return jnp.stack([D_mixed_x, D_mixed_y, D_mixed_z], axis=-1)\n        pass # Your implementation here\n\n# --- How you use it ---\n# space = SpectralSpace(dim=3, size=128)\n# my_scheme = TETRA2(space)\n# projection = GalerkinProjection(scheme=my_scheme, tensor_op=tensor_op)\n</code></pre> <p>The rest of the library (<code>GalerkinProjection</code>, <code>NewtonKrylovSolver</code>) will now use your new scheme without any changes.</p> <p>Implementing a New <code>ProjectionOperator</code></p> <p>Goal: You want to implement an accelerated fixed-point solver, like the <code>Eyre-Milton (EM)</code> or <code>Augmented Lagrangian (ADMM)</code> method. These methods use a different Green's operator \\(\\Gamma^\\gamma\\) that is \"polarized\" by a parameter \\(\\gamma\\).</p> <p>How: You create a new class that inherits from <code>ProjectionOperator</code> and implements the <code>_compute_operator</code> method to build this new \\(\\Gamma^\\gamma\\) tensor.</p> <pre><code>from xpektra.projection_operator import ProjectionOperator\n\nclass EyreMiltonProjection(ProjectionOperator):\n    \"\"\"\n    Implements the polarized Green's operator for the\n    Eyre-Milton (EM) accelerated fixed-point scheme.\n    \"\"\"\n    def __init__(self, scheme, tensor_op, gamma):\n        self.gamma = gamma # Store the acceleration parameter\n        super().__init__(scheme, tensor_op)\n\n    def _compute_operator(self) -&gt; Array:\n        # Implement the specific formula for the EM operator,\n        # which depends on self.gamma and the gradient operator.\n        pass # Your implementation here\n</code></pre> <p>Implementing a New Solver Strategy</p> <p>Goal: You aren't satisfied with the basic fixed-point or Newton-Krylov solvers and want to use <code>Anderson Acceleration</code> to solve the root-finding problem \\(R(\\varepsilon) = 0\\).</p> <p>How: <code>xpektra</code> provides the residual calculation as a self-contained, JIT-able object (like the <code>Residual</code> class in the DBFFT example). You don't need to change any <code>xpektra</code> class. You simply write your own solver function that accepts this <code>Residual</code> object as an argument.</p> <pre><code>import jax\n\n# Your custom solver function\ndef anderson_solver(residual_fn: Callable, eps_initial: Array, max_iter: int):\n    \"\"\"\n    A custom solver that takes a residual function and finds its root\n    using Anderson acceleration.\n    \"\"\"\n    # 1. Get the residual (a JIT-able function-like object)\n    # R = residual_fn\n\n    # 2. Implement the Anderson acceleration logic\n    # ... your solver loop ...\n    # eps_new = ... R(eps_old) ...\n    pass\n\n# --- How you use it ---\n# residual_fn = Residual(...)\n# eps_final = anderson_solver(residual_fn, eps_initial, max_iter=50)\n</code></pre> <p>This powerful, modular design is the central philosophy of <code>xpektra</code>, allowing you to focus on the novel parts of your research while relying on the library's stable, optimized building blocks.</p>"},{"location":"theory/","title":"How <code>xpektra</code> works?","text":"<p>All FFT-based homogenization methods solve the same underlying static equilibrium problem. They differ in how they formulate the problem, how they approximate derivatives, and how they solve the resulting equations.</p> <p>The <code>xpektra</code> library is designed to make these choices modular. You can mix and match components to build the solver that best fits your problem. This guide explains the theory behind those components.</p> <p>There are three main choices you make when building a solver:</p> <ol> <li>The Formulation: (<code>ProjectionOperator</code>) How is the mechanical problem expressed? As a Lippmann-Schwinger equation or a variational (Galerkin) problem?</li> <li>The Discretization <code>Scheme</code>: How are derivatives (like gradient and divergence) calculated? Using the original spectral method or a more stable Finite Difference scheme?</li> <li>The Solver Strategy: How is the final (often non-linear) system of equations solved? With a simple fixed-point iteration or a more robust Newton-Krylov method?</li> </ol>"},{"location":"theory/#core-formulations-the-projectionoperator-choice","title":"Core Formulations (The <code>ProjectionOperator</code> Choice)","text":"<p><code>xpektra</code> provides two main implementations of the <code>ProjectionOperator</code> class, each corresponding to a major school of thought in FFT homogenization.</p>"},{"location":"theory/#the-moulinec-suquet-lippmann-schwinger-approach","title":"The Moulinec-Suquet (Lippmann-Schwinger) Approach","text":"<p>This is the \"classic\" formulation, based on the Lippmann-Schwinger integral equation. The idea is to introduce a simple, homogeneous reference material \\(C^0\\).</p> <p>This splits the problem into a known reference part and an unknown \"polarization\" part \\(\\tau = \\sigma(\\varepsilon) - C^0:\\varepsilon\\). The goal is to solve the fixed-point equation for the strain \\(\\varepsilon\\):</p> \\[ \\varepsilon = \\bar{\\varepsilon} - \\mathcal{G}^0 * \\tau(\\varepsilon) = \\bar{\\varepsilon} - \\mathcal{G}^0 * (\\sigma(\\varepsilon) - C^0 : \\varepsilon) \\] <ul> <li>\\(\\bar{\\varepsilon}\\) is the macroscopic strain.</li> <li>\\(*\\) is a convolution.</li> <li>\\(\\mathcal{G}^0\\) is the Green's operator for the reference material \\(C^0\\).</li> </ul> <p>In Fourier space, the expensive convolution \\(*\\) becomes a simple multiplication \\(\\hat{\\mathcal{G}}^0 \\cdot \\hat{\\tau}\\).</p> <p>How <code>xpektra</code> implements this?</p> <p>This entire formulation is encapsulated by the <code>MoulinecSuquetProjection</code> class. You initialize it with the properties of your chosen reference material (<code>lambda0</code>, <code>mu0</code>), and it pre-computes the \\(\\hat{\\mathcal{G}}^0\\) operator tensor.</p> <p>See Moulinec-Suquet Example for an example.</p>"},{"location":"theory/#the-fourier-galerkin-variational-approach","title":"The Fourier-Galerkin (Variational) Approach","text":"<p>This is a more general and mathematically robust formulation that does not require a reference material. It starts from the weak form of the equilibrium equation (like in the Finite Element Method).</p> <p>It enforces mechanical compatibility (ensuring the strain field comes from a valid displacement) and equilibrium using a single, material-independent projection operator \\(\\hat{G}\\).</p> <p>How <code>xpektra</code> implements this?</p> <p>This is encapsulated by the <code>GalerkinProjection</code> class. This operator is \"universal\" because it is constructed only from the chosen <code>Scheme</code> (i.e., the definition of the derivatives) and is completely independent of any material properties. It is the recommended choice for most problems, especially when using Newton-Krylov solvers.</p> <p>See Fourier-Galerkin Example for an example.</p>"},{"location":"theory/#the-displacement-based-dbfft-approach","title":"The Displacement-Based (DBFFT) Approach","text":"<p>Both methods above solve for the strain \\(\\varepsilon\\) as the primary unknown. An alternative is to solve for the displacement field \\(u\\). The governing equation becomes \\(\\nabla \\cdot (C : \\nabla_s u) = 0\\).</p> <p>How <code>xpektra</code> implements this?</p> <p>The library is flexible enough to allow this. Instead of a <code>ProjectionOperator</code>, you can use the <code>Scheme</code> object directly to get the Fourier-space gradient (<code>.gradient_operator</code>) and divergence (<code>.divergence_operator</code>) operators. You can then write a residual function that solves for <code>u</code>, as shown in the DBFFT example. This approach is powerful because it produces a full-rank system that can be preconditioned very effectively. </p> <p>See DBFFT Example for an example.</p>"},{"location":"theory/#discretization-the-scheme-choice","title":"Discretization (The <code>Scheme</code> Choice)","text":"<p>This is the most critical choice for numerical accuracy and stability. It defines how derivatives are computed.</p>"},{"location":"theory/#the-ringing-problem-spectral-vs-local-schemes","title":"The \"Ringing\" Problem: Spectral vs. Local Schemes","text":"<p>The original FFT methods used a spectral derivative (\\(D_k = i\\xi_k\\)). This is what the <code>Fourier</code> scheme in <code>xpektra</code> implements.</p> <ul> <li>Problem: This scheme has \"global support,\" meaning the derivative at one point depends on all other points. At sharp material interfaces, this causes the Gibbs phenomenon, which appears as spurious oscillations (\"ringing\") in the stress/strain fields. See Gibbs Ringing Artifact for an example.</li> </ul>"},{"location":"theory/#solution-finite-difference-finite-element-schemes","title":"Solution: Finite Difference / Finite Element Schemes","text":"<p>To solve the ringing problem, modern methods use local approximations for derivatives. This is the entire purpose of the <code>Scheme</code> abstract class in <code>xpektra</code>: to let you \"plug in\" different derivative rules.</p> <ul> <li><code>CentralDifference</code>: This scheme is mathematically equivalent to a Linear Finite Element (LFE) formulation on a regular grid. It is extremely effective at eliminating ringing artifacts and is highly recommended.</li> <li><code>RotatedDifference</code>: This scheme (from Willot, 2015) is equivalent to a trilinear Finite Element formulation with reduced integration (like <code>HEX8R</code>). It is also very stable and robust.</li> <li>Extensibility: The library is designed so you can implement your own advanced schemes (like <code>TETRA2</code>) by simply creating a new class that inherits from <code>Scheme</code> and provides the necessary logic.</li> </ul>"},{"location":"theory/#solver-strategy-fixed-point-vs-newton-krylov","title":"Solver Strategy (Fixed-Point vs. Newton-Krylov)","text":"<p>Once you have your formulation (<code>ProjectionOperator</code>) and discretization (<code>Scheme</code>), you need to solve the equations.</p>"},{"location":"theory/#fixed-point-iteration","title":"Fixed-Point Iteration","text":"<p>This is the most basic strategy, used in the original Moulinec-Suquet method. You simply iterate the equation \\(\\varepsilon^{k+1} = \\text{RHS}(\\varepsilon^k)\\) until it converges.</p> <ul> <li>Pros: Very simple to implement (a <code>for</code> loop). Low memory usage.</li> <li>Cons: Very slow convergence. The number of iterations scales linearly with the material contrast (\\(\\sim \\kappa\\)). This is impractical for high-contrast (e.g., 1000:1) or non-linear problems.</li> <li>Advanced Versions: Accelerated methods like Eyre-Milton (EM) or AEM are more advanced fixed-point schemes that converge faster (\\(\\sim \\sqrt{\\kappa}\\)). These are not (yet) implemented in <code>xpektra</code> but can be built using the provided blocks.</li> </ul> <p>See Fixed-Point Example for an example.</p>"},{"location":"theory/#newton-krylov-solvers","title":"Newton-Krylov Solvers","text":"<p>This is the most powerful and robust approach, and it is the primary motivation for building <code>xpektra</code> on JAX.</p> <p>Instead of iterating, we find the root of the residual equation \\(R(\\varepsilon) = 0\\). The Newton-Raphson method does this by iteratively solving the linear system:</p> \\[ J \\cdot \\Delta\\varepsilon = -R(\\varepsilon) \\] <ul> <li><code>R</code> is the residual (the function you want to drive to zero).</li> <li><code>J</code> is the Jacobian of the residual.</li> <li>The linear system is solved with a Krylov method (like Conjugate Gradient, CG).</li> </ul> <p>How <code>xpektra</code> and JAX are used?</p> <p>The power of JAX is that it can compute the Jacobian-Vector Product (JVP), <code>J \\cdot p</code>, without ever forming the massive Jacobian matrix J. The <code>newton_krylov_solver</code> uses <code>jax.jvp</code> to provide this action to the inner CG solver.</p> <ul> <li>Pros: Quadratically fast convergence. Robust for high-contrast and complex non-linear materials.</li> <li>Cons: More complex to set up.</li> <li>Preconditioning: The <code>xpektra</code> DBFFT example shows how to use a preconditioner to dramatically speed up the inner Krylov solver, making this the most efficient method for large problems.</li> </ul> <p>See Fourier-Galerkin Newton-Krylov Example, DBFFT Newton-Krylov Example, Moulinec-Suquet Newton-Krylov Example for an example.</p>"},{"location":"api/projection_operators/","title":"Projection Operators","text":"<p>The formula is given by: </p> \\[\\hat{G}_{ijlm} = \\delta_{im} * D\\xi_{j} * D\\xi^{-1}_{l}\\] <p>where \\(\\delta_{im}\\) is the Kronecker delta, \\(D\\xi_{j}\\) is the gradient operator and \\(D\\xi^{-1}_{l}\\) is the inverse of the gradient operator.</p>"},{"location":"api/projection_operators/#xpektra.projection_operator.GalerkinProjection","title":"<code>xpektra.projection_operator.GalerkinProjection</code>","text":"<p>A 'final' class implementing the material-independent Galerkin projection.</p> <p>This implementation is 'matrix-free'. It does not materialize the full 4th-order Ghat tensor. Instead, it stores the gradient operator (D\u03bes) and its inverse (D\u03be_inv) and computes the projection on the fly. This saves a massive amount of memory.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>DiagonalScheme</code> <p>The differential scheme providing the gradient operator.</p> required <p>Returns:</p> Type Description <p>The Galerkin projection operator.</p> Example <p>projection = GalerkinProjection(scheme) eps_hat = projection.project(field_hat)</p>"},{"location":"api/projection_operators/#xpektra.projection_operator.GalerkinProjection.project","title":"<code>project(field_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the projection on the fly. This is the core of the class.</p> <p>Computes: eps_hat = [\u03b4_im * D\u03be_j * D\u03be_inv_l] * sigma_hat_lm</p> <p>Parameters:</p> Name Type Description Default <code>field_hat</code> <code>Array</code> <p>The input field in Fourier space, shape (..., dim, dim).</p> required <p>Returns:     The projected field in Fourier space, shape (..., dim, dim).</p>"},{"location":"api/projection_operators/#xpektra.projection_operator.MoulinecSuquetProjection","title":"<code>xpektra.projection_operator.MoulinecSuquetProjection</code>","text":"<p>A class implementing the Moulinec-Suquet (MS) Green's operator, which depends on a homogeneous isotropic reference material.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>SpectralSpace</code> <p>The spectral space defining the grid and transform.</p> required <code>lambda0</code> <code>Array</code> <p>The first Lam\u00e9 parameter of the reference material.</p> required <code>mu0</code> <code>Array</code> <p>The second Lam\u00e9 parameter (shear modulus) of the reference material.</p> required <p>Returns:     The Moulinec-Suquet projection operator.</p> Example <p>Ghat = MoulinecSuquetProjection(space, lambda0, mu0).compute_operator()</p>"},{"location":"api/projection_operators/#xpektra.projection_operator.MoulinecSuquetProjection.compute_operator","title":"<code>compute_operator() -&gt; jaxlib._jax.Array</code>","text":"<p>Implements the Moulinec-Suquet projection operator.</p> <p>Returns:</p> Type Description <code>Array</code> <p>The Green's operator Ghat, shape (..., dim, dim, dim, dim).</p>"},{"location":"api/scheme_api/","title":"Discretization Schemes","text":"<p>In <code>xpektra</code>, we define a discretization scheme which allows us to correctly define various differentiation operators. To do so, we need two information:</p> <ul> <li>The underlying grid in the physical space i.e if regular, staggered, etc.</li> <li>The differentiation formula to be used.</li> </ul> <p>In order to facilitate this, we define a base class <code>Scheme</code> which provides the necessary infrastructure to define a discretization scheme.</p> <p>The <code>Scheme</code> class is a base class for all the discretization schemes. One can create different discretization schemes by subclassing the <code>Scheme</code> class and implementing the <code>formula</code> method. The <code>formula</code> method should return the gradient operator field for a given wavenumber and grid spacing. In <code>xpektra</code>, we have implemented the <code>CartesianScheme</code> which takes a regular grid in physical space and returns the gradient operator field in spectral space.</p> <p>To define the differentiation formula, we need to implement the <code>formula</code> method. The <code>formula</code> method should return the gradient operator field for a given wavenumber and grid spacing. In <code>xpektra</code>, we have various differentiation schemes available which can be used to define the differentiation formula.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\iota \\xi\\] <p>where \\(\\iota\\) is the imaginary unit and \\(\\xi\\) is the wavenumber.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\iota \\frac{\\sin(\\xi \\Delta x)}{\\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\frac{\\exp(\\iota \\xi \\Delta x) - 1}{\\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\frac{1 - \\exp(-\\iota \\xi \\Delta x)}{\\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\frac{2 \\iota \\tan(\\xi \\Delta x / 2) \\Delta x}{2 \\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\iota \\frac{8 \\sin(\\xi \\Delta x) - 2 \\sin(2 \\xi \\Delta x) + 8 \\sin(3 \\xi \\Delta x) - \\sin(4 \\xi \\Delta x)}{6 \\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\iota \\frac{9 \\sin(\\xi \\Delta x) - 3 \\sin(2 \\xi \\Delta x) + \\sin(3 \\xi \\Delta x)}{6 \\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p> <p>The formula is given by:</p> \\[D(\\xi) = \\iota \\frac{8 \\sin(\\xi \\Delta x) - 2 \\sin(2 \\xi \\Delta x) + 8 \\sin(3 \\xi \\Delta x) - \\sin(4 \\xi \\Delta x)}{12 \\Delta x}\\] <p>where \\(\\iota\\) is the imaginary unit, \\(\\xi\\) is the wavenumber and \\(\\Delta x\\) is the grid spacing.</p>"},{"location":"api/scheme_api/#xpektra.scheme.Scheme","title":"<code>xpektra.scheme.Scheme</code>","text":"<p>Abstract base class for a complete discretization strategy.</p> <p>A Scheme is a self-contained object responsible for generating the discrete gradient operator based on a given spectral space.</p>"},{"location":"api/scheme_api/#xpektra.scheme.Scheme.compute_gradient_operator","title":"<code>compute_gradient_operator(wavenumbers_mesh: list[jax.jaxlib._jax.Array]) -&gt; jaxlib._jax.Array</code>","text":"<p>The primary output of any scheme. The gradient operator field has shape ( (N,)dim, (dim,)rank).</p>"},{"location":"api/scheme_api/#xpektra.scheme.Scheme.is_compatible","title":"<code>is_compatible(transform) -&gt; bool</code>","text":"<p>Checks if the scheme is compatible with the given transform.</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme","title":"<code>xpektra.scheme.DiagonalScheme</code>","text":"<p>Base class for schemes operating on a uniform Cartesian grid where the differentiation is diagonal in Fourier space.</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.__init__","title":"<code>__init__(space: SpectralSpace)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.apply_gradient","title":"<code>apply_gradient(u_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the gradient operator on the fly. Computes: grad_hat_ij = D\u03be_i * u_hat_j</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.apply_symmetric_gradient","title":"<code>apply_symmetric_gradient(u_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the symmetric gradient operator on the fly. Computes: eps_hat_ij = 0.5 * (D\u03be_i * u_hat_j + D\u03be_j * u_hat_i)</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.apply_divergence","title":"<code>apply_divergence(u_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the divergence operator on the fly. Computes: div_hat_i = D\u03be_j * u_hat_ji</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.apply_laplacian","title":"<code>apply_laplacian(u_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the Laplacian operator on the fly. Computes: lap_hat = -|D\u03be|^2 * u_hat</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.compute_gradient_operator","title":"<code>compute_gradient_operator(wavenumbers_mesh) -&gt; jaxlib._jax.Array</code>","text":"<p>Builds the full gradient operator field using the scheme's formula.</p>"},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.is_compatible","title":"<code>is_compatible(transform)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.DiagonalScheme.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":"<p>The core formula for the discrete derivative in Fourier space. Must be implemented by concrete schemes.</p>"},{"location":"api/scheme_api/#xpektra.scheme.FourierScheme","title":"<code>xpektra.scheme.FourierScheme</code>","text":"<p>Class implementing the standard spectral 'Fourier' derivative.</p>"},{"location":"api/scheme_api/#xpektra.scheme.FourierScheme.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.CentralDifference","title":"<code>xpektra.scheme.CentralDifference</code>","text":"<p>Implements the standard central difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.CentralDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.ForwardDifference","title":"<code>xpektra.scheme.ForwardDifference</code>","text":"<p>Implements the forward difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.ForwardDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.BackwardDifference","title":"<code>xpektra.scheme.BackwardDifference</code>","text":"<p>Implements the backward difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.BackwardDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.RotatedDifference","title":"<code>xpektra.scheme.RotatedDifference</code>","text":"<p>Implements the rotated finite difference scheme (Willot/HEX8R).</p>"},{"location":"api/scheme_api/#xpektra.scheme.RotatedDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.FourthOrderCentralDifference","title":"<code>xpektra.scheme.FourthOrderCentralDifference</code>","text":"<p>Implements the fourth order difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.FourthOrderCentralDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.SixthOrderCentralDifference","title":"<code>xpektra.scheme.SixthOrderCentralDifference</code>","text":"<p>Implements the sixth order difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.SixthOrderCentralDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/scheme_api/#xpektra.scheme.EighthOrderCentralDifference","title":"<code>xpektra.scheme.EighthOrderCentralDifference</code>","text":"<p>Implements the eighth order difference scheme.</p>"},{"location":"api/scheme_api/#xpektra.scheme.EighthOrderCentralDifference.formula","title":"<code>formula(xi, dx, iota, factor)</code>","text":""},{"location":"api/spectral_operator_api/","title":"Spectral Operator","text":"<p>In <code>xpektra</code>, spectral operators are defined to perform various operations in the spectral domain. These operators are essential for implementing spectral methods for solving partial differential equations. The spectral operators are built upon the discretization schemes defined in the <code>scheme</code> module and the spectral spaces defined in the <code>space</code> module.</p> <p>The <code>SpectralOperator</code> class serves as a unified interface for various spectral operations, including gradient, symmetric gradient, divergence, and Laplacian operations. It also provides methods for forward and inverse Fourier transforms, as well as tensor operations like double dot product, dot product, trace, and dyadic product.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator","title":"<code>xpektra.spectral_operator.SpectralOperator</code>","text":"<p>A spectral operator defined by spectral space, differential scheme. It provides methods to compute gradient, divergence, symmetric gradient, and also tensor operations like dot, ddot, trace, transpose, and dyadic product.</p> <p>*Arguuments - space: The spectral space. - scheme: The differential scheme.</p> <p>Returns - The spectral operator.</p> <p>Example:</p> <pre><code>operator = SpectralOperator(space, scheme)\ngrad_u = operator.grad(u)\ndiv_v = operator.div(v)\nsym_grad_u = operator.sym_grad(u)\n</code></pre>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.grad","title":"<code>grad(u: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the gradient operator to the input real-valued array u.</p> <p>Arguments - u: A real-valued array of shape (N,)*dim.</p> <p>Returns - The gradient of u, a real-valued array of shape (N,)*dim + (dim,).</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.sym_grad","title":"<code>sym_grad(u: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the symmetric gradient operator to the input real-valued array u.</p> <p>Arguments - u: A real-valued array of shape (N,)*dim.</p> <p>Returns - The symmetric gradient of u, a real-valued array of shape (N,)*dim + (dim, dim).</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.div","title":"<code>div(v: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the divergence operator to the input real-valued array v.</p> <p>Arguments - v: A real-valued array of shape (N,)dim + (dim,). Returns - The divergence of v, a real-valued array of shape (N,)dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.laplacian","title":"<code>laplacian(u: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the Laplacian operator to the input real-valued array u.</p> <p>Arguments - u: A real-valued array of shape (N,)dim. Returns - The Laplacian of u, a real-valued array of shape (N,)dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.forward","title":"<code>forward(u: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the forward transform to the input real-valued array u.</p> <p>Arguments - u: A real-valued array of shape (N,)dim. Returns - The transformed array u_hat, a complex-valued array of shape (N,)dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.inverse","title":"<code>inverse(u_hat: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the inverse transform to the input complex-valued array u_hat.</p> <p>Arguments - u_hat: A complex-valued array of shape (N,)dim. Returns - The inverse transformed array u, a real-valued array of shape (N,)dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.ddot","title":"<code>ddot(A: jaxlib._jax.Array, B: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the double dot product to the input arrays A and B.</p> <p>Arguments - A: A real-valued array of shape (N,)dim. - B: A real-valued array of shape (N,)dim. Returns - The double dot product of A and B, a real-valued array of shape (N,)*dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.dot","title":"<code>dot(A: jaxlib._jax.Array, B: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the dot product to the input arrays A and B.</p> <p>Arguments - A: A real-valued array of shape (N,)dim. - B: A real-valued array of shape (N,)dim. Returns - The dot product of A and B, a real-valued array of shape (N,)*dim.</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.trace","title":"<code>trace(A: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the trace operator to the input array A.</p> <p>Arguments - A: A real-valued array of shape (N,)dim. Returns* - The trace of A, a real-valued array of shape (N,).</p>"},{"location":"api/spectral_operator_api/#xpektra.spectral_operator.SpectralOperator.dyad","title":"<code>dyad(A: jaxlib._jax.Array, B: jaxlib._jax.Array) -&gt; jaxlib._jax.Array</code>","text":"<p>Applies the dyadic product to the input arrays A and B.</p> <p>Arguments - A: A real-valued array of shape (N,)dim. - B: A real-valued array of shape (N,)dim. Returns - The dyadic product of A and B, a real-valued array of shape (N,)*dim.</p>"},{"location":"api/spectral_space_api/","title":"Spectral Space","text":""},{"location":"api/spectral_space_api/#xpektra.SpectralSpace","title":"<code>xpektra.SpectralSpace</code>","text":"<p>Defines the spectral space</p> <p>Arguments</p> <ul> <li>shape: The shape of the spectral space.</li> <li>lengths: The lengths of the spectral space.</li> <li>transform: The transform to be used in the spectral space.</li> </ul> <p>Returns - The spectral space.</p> <pre><code>space = SpectralSpace(shape=(10,), lengths=(1.0,), transform=FFTTransform(dim=1))\nspace.get_wavenumber_vector()\n</code></pre>"},{"location":"api/spectral_space_api/#xpektra.SpectralSpace.get_wavenumber_mesh","title":"<code>get_wavenumber_mesh() -&gt; list[jax.jaxlib._jax.Array]</code>","text":"<p>Creates a list of coordinate arrays for the wavenumbers.</p> <p>Returns - A list of arrays representing the wavenumber meshgrid.</p>"},{"location":"assets/xpektra_fft/","title":"Xpektra fft","text":"<pre><code>import numpy as np\nfrom PIL import Image, ImageDraw, ImageFont\n\ndef text_to_grid(text=\"xpektra\", n=128, font_size_ratio=0.6):\n    \"\"\"\n    Generate a 2D numpy array of size n x n containing a binary image\n    of the given text centered in the grid.\n\n    Parameters\n    ----------\n    text : str\n        The text to render (default: 'xpektra').\n    n : int\n        The size of the grid (n x n pixels).\n    font_size_ratio : float\n        Fraction of the grid height used for font size (default: 0.6).\n\n    Returns\n    -------\n    grid : np.ndarray\n        A binary array (n, n) with 1 where text appears and 0 elsewhere.\n    \"\"\"\n    # Create a blank image\n    img = Image.new(\"L\", (n, n), 0)\n    draw = ImageDraw.Draw(img)\n\n    # Choose a font (default font used if none available)\n    font_size = int(n * font_size_ratio)\n    try:\n        font = ImageFont.truetype(\"DejaVuSans-Bold.ttf\", font_size)\n    except IOError:\n        font = ImageFont.load_default()\n\n    # Get text bounding box\n    text_bbox = draw.textbbox((0, 0), text, font=font)\n    text_width, text_height = text_bbox[2] - text_bbox[0], text_bbox[3] - text_bbox[1]\n\n    # Center position\n    x = (n - text_width) // 2\n    y = (n - text_height) // 2\n\n    # Draw text in white (255)\n    draw.text((x, y), text, fill=255, font=font)\n\n    # Convert to numpy binary array\n    grid = np.array(img)\n    grid = (grid &gt; 127).astype(int)\n\n    return grid\n</code></pre> <pre><code>import matplotlib.pyplot as plt\n\nphase = text_to_grid(\"xpektra\", n=251, font_size_ratio=0.15)\nplt.imshow(phase, cmap=\"gray\")\n\nplt.show()\n</code></pre> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\nimport equinox as eqx\n\nimport matplotlib.pyplot as plt\nfrom xpektra import (\n    SpectralSpace,\n    TensorOperator,\n    make_field,\n)\nfrom xpektra.scheme import RotatedDifference, Fourier, ForwardDifference\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\n</code></pre> <pre><code>N = phase.shape[0]\nndim = 2\nlength = 1\n\ntensor = TensorOperator(dim=ndim)\nspace = SpectralSpace(size=N, dim=ndim, length=length)\n\n\n# Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 1.0, 1e-3\nmu1, mu2 = 0.25, 0.25\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n\n\ncb = plt.imshow(lambdas, cmap=\"managua_r\")\nplt.colorbar(cb)\nplt.show()\n</code></pre> <pre><code>dofs_shape = make_field(dim=ndim, N=N, rank=2).shape\n\n\n@eqx.filter_jit\ndef strain_energy(eps_flat: Array) -&gt; Array:\n    eps = eps_flat.reshape(dofs_shape)\n    eps_sym = 0.5 * (eps + tensor.trans(eps))\n    energy = 0.5 * jnp.multiply(lambdas, tensor.trace(eps_sym) ** 2) + jnp.multiply(\n        mu, tensor.trace(tensor.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n\n\nGhat = GalerkinProjection(\n    scheme=RotatedDifference(space=space), tensor_op=tensor\n).compute_operator()\n\n\nclass Residual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    Ghat: Array\n    space: SpectralSpace = eqx.field(static=True)\n    tensor_op: TensorOperator = eqx.field(static=True)\n    dofs_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, eps_flat: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        eps_flat = eps_flat.reshape(-1)\n        sigma = compute_stress(eps_flat)\n        residual_field = self.space.ifft(\n            self.tensor_op.ddot(\n                self.Ghat, self.space.fft(sigma.reshape(self.dofs_shape))\n            )\n        )\n        return jnp.real(residual_field).reshape(-1)\n\n\nclass Jacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    Ghat: Array\n    space: SpectralSpace = eqx.field(static=True)\n    tensor_op: TensorOperator = eqx.field(static=True)\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, deps_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n\n        deps_flat = deps_flat.reshape(-1)\n        dsigma = compute_stress(deps_flat)\n        jvp_field = self.space.ifft(\n            self.tensor_op.ddot(\n                self.Ghat, self.space.fft(dsigma.reshape(self.dofs_shape))\n            )\n        )\n        return jnp.real(jvp_field).reshape(-1)\n\n\napplied_strains = jnp.diff(jnp.linspace(0, 1e-1, num=2))\n\ndeps = make_field(dim=2, N=N, rank=2)\neps = make_field(dim=2, N=N, rank=2)\n\nresidual_fn = Residual(Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape)\njacobian_fn = Jacobian(Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape)\n\n\nfor inc, deps_avg in enumerate(applied_strains):\n    # solving for elasticity\n    deps[:, :, 0, 0] = deps_avg\n    deps[:, :, 1, 1] = deps_avg\n\n    b = -residual_fn(deps)\n    eps = eps + deps\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_fn,\n        jacobian=jacobian_fn,\n        tol=1e-8,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n    eps = final_state[2]\n\neps = final_state[2].reshape(dofs_shape)\nsig = compute_stress(final_state[2]).reshape(dofs_shape)\n</code></pre> <pre><code>CG error = 75.84651724222920\nConverged, Residual value : 2.2839933409951885e-13\n</code></pre> <pre><code>from cmap import Colormap\n</code></pre> <pre><code>\n</code></pre> <pre><code>fig, ax1 = plt.subplots(1, 1, figsize=(5, 5), layout=\"constrained\")\nmask = phase == 1\neps_comp = eps.at[:, :, 0, 1].get()\n#mask2 = np.abs(eps_comp) &lt; 0.001\n#mask = mask | mask2\neps_masked = np.ma.array(eps_comp, mask=mask)\n\ncb1 = ax1.imshow(\n    eps_masked[int(N/2)-20:int(N/2)+30, :],\n    cmap=Colormap(\"fusion\").to_mpl(),\n)\n\n#eps_masked = np.ma.array(eps.at[:, :, 0, 1].get(), mask=~mask)\n\n#ax1.imshow(eps_masked[int(N/2)-10:int(N/2)+20, :], cmap=\"managua_r\", alpha=0.5)\nax1.contour(phase[int(N/2)-20:int(N/2)+30, :], colors=\"lightgrey\", levels=[0.5])\n#ax1.contour(eps_masked[int(N/2)-40:int(N/2)+60, :], cmap=Colormap(\"fusion\").to_mpl(), levels=16) #cmap=Colormap(\"fusion\").to_mpl(), levels=4)\n#fig.colorbar(cb1)\nax1.axis(\"off\")\nplt.savefig(\"xpektra_fft.svg\")\n</code></pre> <pre><code>fig, ax1 = plt.subplots(1, 1, figsize=(5, 5), layout=\"constrained\")\nmask = phase == 1\neps_comp = eps.at[:, :, 0, 1].get()\n#mask2 = np.abs(eps_comp) &lt; 0.001\n#mask = mask | mask2\neps_masked = np.ma.array(eps_comp, mask=mask)\n\ncb1 = ax1.imshow(\n    eps_masked[int(N/2)-20:int(N/2)+30, :],\n    cmap=Colormap(\"icefire\").to_mpl(),  \n)\n\n#eps_masked = np.ma.array(eps.at[:, :, 0, 1].get(), mask=~mask)\n\n#ax1.imshow(eps_masked[int(N/2)-10:int(N/2)+20, :], cmap=\"managua_r\", alpha=0.5)\nax1.contour(phase[int(N/2)-20:int(N/2)+30, :], colors=\"lightgrey\", levels=[0.5])\n#ax1.contour(eps_masked[int(N/2)-40:int(N/2)+60, :], cmap=Colormap(\"fusion\").to_mpl(), levels=16) #cmap=Colormap(\"fusion\").to_mpl(), levels=4)\n#fig.colorbar(cb1)\nax1.axis(\"off\")\nplt.savefig(\"xpektra_dark_fft.svg\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/computational_homogenization/","title":"Homogenization","text":"<p>In this example, we demonstrate how to perform computational homogenization using the spectral solver framework. We will define a microstructure, apply macroscopic strains, and compute the effective material properties.</p> <p>We will make use of the differentiable nature of <code>xpektra</code> to compute the tangent stiffness matrix via automatic differentiation using <code>JAX</code>.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nimport time\nfrom functools import partial\n\nimport equinox as eqx\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom jax import Array\nfrom skimage.morphology import disk\n</code></pre> <p>We start by importing the necessary libraries and configuring JAX for double-precision computations.</p> <pre><code>from xpektra import FFTTransform, SpectralOperator, SpectralSpace, make_field\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    NewtonSolver,\n    conjugate_gradient,\n)\n</code></pre>"},{"location":"examples/computational_homogenization/#define-microstructure","title":"Define Microstructure","text":"<p>We define a simple microstructure consisting of a circular inclusion in a matrix material.</p> <pre><code>volume_fraction_percentage = 0.007\n\nlength = 0.1\nH, L = (199, 199)\n\ndx = length / H\ndy = length / L\n\nHmid = int(H / 2)\nLmid = int(L / 2)\nvol_inclusion = volume_fraction_percentage * (length * length)\nr = (\n    int(np.sqrt(vol_inclusion / np.pi) / dx) + 1\n)  # Since the rounding off leads to smaller fraction therefore we add 1.\n\nstructure = jnp.zeros((H, L))\nstructure = structure.at[Hmid - r : Hmid + 1 + r, Lmid - r : Lmid + 1 + r].add(disk(r))\n\nndim = len(structure.shape)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(structure, cmap=\"gray\")\nplt.colorbar()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/computational_homogenization/#define-material-properties","title":"Define Material Properties","text":"<p>We assume the inclusion to be stiffer than the matrix.</p> <pre><code># material parameters, lames constant\nlambda_matrix = 2.0\nmu_matrix = 1.0\n\nlambda_inclusion = 10.0\nmu_inclusion = 5.0\n\nlambda_field = lambda_matrix * (1 - structure) + lambda_inclusion * (structure)\nmu_field = mu_matrix * (1 - structure) + mu_inclusion * (structure)\n</code></pre>"},{"location":"examples/computational_homogenization/#defining-spectral-functions","title":"Defining Spectral functions","text":"<pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=structure.shape, transform=fft_transform\n)\ndiff_scheme = RotatedDifference(space=space)\n\nop = SpectralOperator(\n    scheme=diff_scheme,\n    space=space,\n)\n</code></pre> <pre><code>dofs_shape = make_field(dim=ndim, shape=structure.shape, rank=2).shape\n</code></pre> <pre><code>@eqx.filter_jit\ndef strain_energy(eps_flat: Array) -&gt; Array:\n    eps = eps_flat.reshape(dofs_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambda_field, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu_field, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jit(jax.jacrev(strain_energy))\n</code></pre> <p>We now define the Galerkin projection operator.</p> <pre><code>Ghat = GalerkinProjection(scheme=diff_scheme)\n</code></pre> <pre><code>@eqx.filter_jit\ndef residual_fn(eps_fluc_flat: Array, macro_strain: Array) -&gt; Array:\n    \"\"\"\n    A function that computes the residual of the problem based on the given macro strain.\n    It takes only the flattened vector of fluctuation strain and a macro strain.\n\n    Args:\n        eps_fluc_flat: Flattened vector of fluctuation strain.\n        macro_strain: Macro strain.\n\n    Returns:\n        Residual field.\n    \"\"\"\n\n    eps_fluc = eps_fluc_flat.reshape(dofs_shape)\n    eps_macro = jnp.zeros(dofs_shape)\n    eps_macro = eps_macro.at[:, :, 0, 0].set(macro_strain[0])\n    eps_macro = eps_macro.at[:, :, 1, 1].set(macro_strain[1])\n    eps_macro = eps_macro.at[:, :, 0, 1].set(macro_strain[2] / 2.0)\n    eps_macro = eps_macro.at[:, :, 1, 0].set(macro_strain[2] / 2.0)\n\n    eps_total = eps_fluc + eps_macro\n    eps_flat = eps_total.reshape(-1)\n    sigma = compute_stress(eps_flat)\n    residual_field = op.inverse(Ghat.project(op.forward(sigma.reshape(dofs_shape))))\n    return jnp.real(residual_field).reshape(-1)\n\n\n@eqx.filter_jit\ndef jacobian_fn(deps_flat: Array) -&gt; Array:\n    \"\"\"\n    The Jacobian is a linear operator, so its represents the Jacobian-vector product.\n    For this linear elastic problem, we use the stress relation to compute the Jacobian.\n\n    Args:\n        deps_flat: The flattened displacement gradient field.\n\n    Returns:\n        The flattened Jacobian-vector product.\n    \"\"\"\n\n    deps_flat = deps_flat.reshape(-1)\n    dsigma = compute_stress(deps_flat)\n    jvp_field = op.inverse(Ghat.project(op.forward(dsigma.reshape(dofs_shape))))\n    return jnp.real(jvp_field).reshape(-1)\n</code></pre> <p>We can define a function to compute the local constitutive response given a macroscopic strain. The function will solve the local problem using a Newton-Krylov solver and return the homogenized stress.</p> <pre><code>@eqx.filter_jit\ndef local_constitutive_update(macro_strain):\n    # set macroscopic loading to the residual\n    # important for the implicit differentiation to work correctly\n    # also, partial from functools and not from equinox\n    residual_fn_partial = jax.jit(partial(residual_fn, macro_strain=macro_strain))\n\n    # define the newton solver with the krylov solver\n    solver = NewtonSolver(\n        tol=1e-8,\n        max_iter=20,\n        krylov_solver=conjugate_gradient,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n\n    # initialize the initial guess for the local strain field\n    eps_init = jnp.array(make_field(dim=2, shape=structure.shape, rank=2))\n\n    # solve for the fluctuation strain field, the residual is the\n    # right hand side is defined based on the initial guess\n    eps_fluc = solver.solve(\n        x=eps_init.reshape(-1),\n        f=residual_fn_partial,\n        b=-residual_fn_partial(eps_init.reshape(-1)),\n        jac=jacobian_fn,\n    )\n\n    # compute the actual micro strain field\n    # eps fluctuation is added to the initial guess\n    eps_macro = eps_init.at[:, :, 0, 0].set(macro_strain[0])\n    eps_macro = eps_macro.at[:, :, 1, 1].set(macro_strain[1])\n    eps_macro = eps_macro.at[:, :, 0, 1].set(macro_strain[2] / 2.0)\n    eps_macro = eps_macro.at[:, :, 1, 0].set(macro_strain[2] / 2.0)\n\n    eps = eps_fluc.reshape(dofs_shape) + eps_macro\n\n    # compute the actual micro stress field\n    sig = compute_stress(eps.reshape(-1)).reshape(dofs_shape)\n\n    # get the macro stress\n    macro_sigma = jnp.array(\n        [\n            jnp.sum(sig.at[:, :, 0, 0].get() * dx * dy),\n            jnp.sum(sig.at[:, :, 1, 1].get() * dx * dy),\n            0.5\n            * (\n                jnp.sum(sig.at[:, :, 1, 0].get() * dx * dy)\n                + jnp.sum(sig.at[:, :, 0, 1].get() * dx * dy)\n            ),\n        ]\n    )\n    macro_sigma = macro_sigma / length**2\n\n    return macro_sigma, (macro_sigma, sig, eps)\n</code></pre> <p>We use the <code>jax.jacfwd</code> to differentiate the stress computation function to obtain the tangent operator.</p> \\[ \\mathbb{C} = \\frac{\\partial \\sigma(\\varepsilon_\\text{macro})}{\\partial \\varepsilon_\\text{macro}} \\] <pre><code>tangent_operator_and_state = jax.jacfwd(local_constitutive_update, has_aux=True)\n</code></pre> <pre><code>deps = jnp.array([1.2, 1.0, 1])\n\nstart_time = time.time()\ntangent, state = tangent_operator_and_state(deps)\nend_time = time.time()\nprint(f\"Time taken: {end_time - start_time} seconds\")\n</code></pre> <pre><code>Converged, Residual value : 6.819522211101115e-09\nTime taken: 6.046091556549072 seconds\n</code></pre> <p>The homogenized tangent stiffness matrix is thus computed as:</p> <pre><code>print(f\"tangent: {tangent}\")\n</code></pre> <pre><code>tangent: [[ 4.03381561e+00  2.01484013e+00 -3.93671797e-18]\n [ 2.01484013e+00  4.03381561e+00 -3.28159093e-18]\n [-7.00125670e-19  1.90780936e-18  1.00910293e+00]]\n</code></pre> <p>Plotting the micro stress field</p> <pre><code>plt.figure(figsize=(4, 4))\nplt.imshow(state[1][:, :, 0, 0], cmap=\"berlin\", origin=\"lower\")\nplt.colorbar(label=r\"$\\sigma_{xx}$\")\nplt.title(\"Micro Stress Field\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/differential_operator/","title":"Gibbs Ringing Artifact","text":"<p>In this example, we see the effect of Gibbs ringing artifact on the stress field. The original FFT methods used a spectral derivative (\\(D_k = i\\xi_k\\)). This scheme has \"global support,\" meaning the derivative at one point depends on all other points. At sharp material interfaces, this causes the Gibbs phenomenon, which appears as spurious oscillations (\"ringing\") in the stress/strain fields.</p> <p>In this notebook, we solve the same problem using a local scheme</p> <ul> <li><code>CentralDifference</code>: This scheme is mathematically equivalent to a Linear Finite Element (LFE) formulation on a regular grid. It is extremely effective at eliminating ringing artifacts and is highly recommended.</li> <li><code>RotatedDifference</code>: This scheme (from Willot, 2015) is equivalent to a trilinear Finite Element formulation with reduced integration (like <code>HEX8R</code>). It is also very stable and robust.</li> </ul> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\n\nimport jax.numpy as jnp\nimport numpy as np\n\nfrom jax import Array\nimport equinox as eqx\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom skimage.morphology import footprint_rectangle as rectangle\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfrom xpektra import (\n    SpectralSpace,\n    TensorOperator,\n    make_field,\n)\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\n</code></pre> <p>In <code>xpektra</code>, we can import various schemes from the <code>scheme</code> module.</p> <pre><code>from xpektra.scheme import RotatedDifference, Fourier, CentralDifference, CartesianScheme\n</code></pre> <pre><code>def param(X, soft, hard):\n    return soft * jnp.ones_like(X) * (X) + hard * jnp.ones_like(X) * (1 - X)\n\n\ndef test_microstructure(N, scheme, length):\n    H, L = (N, N)\n    r = int(H / 2)\n\n    structure = np.zeros((H, L))\n    structure[:r, -r:] += rectangle((r, r))\n    structure = np.flipud(structure)\n    structure = np.fliplr(structure)\n\n    ndim = len(structure.shape)\n    N = structure.shape[0]\n\n    tensor = TensorOperator(dim=ndim)\n    space = SpectralSpace(size=N, dim=ndim, length=length)\n\n    if scheme == \"rotated\":\n        scheme = RotatedDifference(space=space)\n    elif scheme == \"fourier\":\n        scheme = Fourier(space=space)\n    elif scheme == \"central\":\n        scheme = CentralDifference(space=space)\n    else:\n        raise ValueError(f\"Invalid scheme: {scheme}\")\n\n    # material parameters\n    phase_contrast = 1000.0\n\n    # lames constant\n    lambda_modulus = {\"soft\": 1.0, \"hard\": phase_contrast}\n    shear_modulus = {\"soft\": 1.0, \"hard\": phase_contrast}\n\n    bulk_modulus = {}\n    bulk_modulus[\"soft\"] = lambda_modulus[\"soft\"] + 2 * shear_modulus[\"soft\"] / 3\n    bulk_modulus[\"hard\"] = lambda_modulus[\"hard\"] + 2 * shear_modulus[\"hard\"] / 3\n\n    # material parameters\n    \u03bc0 = param(\n        structure, soft=shear_modulus[\"soft\"], hard=shear_modulus[\"hard\"]\n    )  # shear     modulus\n    \u03bb0 = param(\n        structure, soft=lambda_modulus[\"soft\"], hard=lambda_modulus[\"hard\"]\n    )  # shear     modulus\n\n    dofs_shape = make_field(dim=ndim, N=N, rank=2).shape\n\n    @eqx.filter_jit\n    def strain_energy(eps_flat: Array) -&gt; Array:\n        eps = eps_flat.reshape(dofs_shape)\n        eps_sym = 0.5 * (eps + tensor.trans(eps))\n        energy = 0.5 * jnp.multiply(\u03bb0, tensor.trace(eps_sym) ** 2) + jnp.multiply(\n            \u03bc0, tensor.trace(tensor.dot(eps_sym, eps_sym))\n        )\n        return energy.sum()\n\n    compute_stress = jax.jacrev(strain_energy)\n\n    Ghat = GalerkinProjection(scheme=scheme)\n\n    class Residual(eqx.Module):\n        \"\"\"A callable module that computes the residual vector.\"\"\"\n\n        Ghat: CartesianScheme\n        space: SpectralSpace = eqx.field(static=True)\n        tensor_op: TensorOperator = eqx.field(static=True)\n        dofs_shape: tuple = eqx.field(static=True)\n\n        # We can even pre-define the stress function if it's always the same\n        # For this example, we'll keep your original `compute_stress` function\n        # available in the global scope.\n\n        @eqx.filter_jit\n        def __call__(self, eps_flat: Array) -&gt; Array:\n            \"\"\"\n            This makes instances of this class behave like a function.\n            It takes only the flattened vector of unknowns, as required by the solver.\n            \"\"\"\n            eps_flat = eps_flat.reshape(-1)\n            sigma = compute_stress(\n                eps_flat\n            )  # Assumes compute_stress is defined elsewhere\n            residual_field = self.space.ifft(\n                self.Ghat.project(self.space.fft(sigma.reshape(self.dofs_shape)))\n            )\n            return jnp.real(residual_field).reshape(-1)\n\n    class Jacobian(eqx.Module):\n        \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n        Ghat: CartesianScheme\n        space: SpectralSpace = eqx.field(static=True)\n        tensor_op: TensorOperator = eqx.field(static=True)\n        dofs_shape: tuple = eqx.field(static=True)\n\n        @eqx.filter_jit\n        def __call__(self, deps_flat: Array) -&gt; Array:\n            \"\"\"\n            The Jacobian is a linear operator, so its __call__ method\n            represents the Jacobian-vector product.\n            \"\"\"\n\n            deps_flat = deps_flat.reshape(-1)\n            dsigma = compute_stress(deps_flat)\n            jvp_field = self.space.ifft(\n                self.Ghat.project(self.space.fft(dsigma.reshape(self.dofs_shape)))\n            )\n            return jnp.real(jvp_field).reshape(-1)\n\n    eps = make_field(dim=ndim, N=N, rank=2)\n    residual_fn = Residual(\n        Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape\n    )\n    jacobian_fn = Jacobian(\n        Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape\n    )\n\n    deps = make_field(dim=ndim, N=N, rank=2)\n    deps[:, :, 0, 1] = 5e-1\n    deps[:, :, 1, 0] = 5e-1\n\n    b = -residual_fn(deps)\n    eps = eps + deps\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_fn,\n        jacobian=jacobian_fn,\n        tol=1e-10,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n    eps = final_state[2]\n\n    sig = compute_stress(eps.reshape(-1)).reshape(dofs_shape)\n\n    return sig.at[:, :, 0, 1].get(), structure\n</code></pre> <pre><code>N = 99\nlength = 1\n\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 5))\n\n\nfor index, scheme in enumerate([\"fourier\", \"central\", \"rotated\"]):\n\n    sig_xy, structure = test_microstructure(N=N, scheme=scheme, length=length)\n    dx = length / N\n    N_inset = int(0.1 / dx)\n\n\n    cb = axs[index].imshow(sig_xy, origin=\"lower\", cmap=\"berlin\",)\n    axs[index].set_title(f\"{scheme} scheme\")\n\n    axs[index].set_xlim(int(N / 2) - N_inset, int(N / 2) + N_inset)\n    axs[index].set_ylim(int(N / 2) - N_inset, int(N / 2) + N_inset)\n    axs[index].plot(\n        [int(N / 2) - N_inset, int(N / 2)], [int(N / 2), int(N / 2)], color=\"k\", zorder=20\n    )\n    axs[index].plot(\n        [int(N / 2), int(N / 2)],\n        [int(N / 2), int(N / 2) + N_inset],\n        color=\"k\",\n        zorder=20,\n    )\n\n    divider = make_axes_locatable(axs[index])\n    cax = divider.append_axes(\"bottom\", size=\"10%\", pad=0.6)\n    fig.colorbar(cb, cax=cax, label=r\"$\\sigma_{xy}$\", orientation=\"horizontal\", location=\"bottom\")\n\nplt.show()\n</code></pre> <pre><code>CG error = 1809191201.65288829803467\nCG error = 180711.28018052203697\nCG error = 46714.20145051593863\nCG error = 14617.25232148401119\nCG error = 5832.59698513089097\nCG error = 2431.65598926188977\nCG error = 3116.29740077978477\nCG error = 614.33968567417730\nCG error = 952.91201451378811\nCG error = 127.43347812995538\nCG error = 219.72885043808103\nCG error = 30.34384937912854\nCG error = 53.54063847293286\nCG error = 7.48889951501528\nCG error = 13.38287004868258\nCG error = 1.88468977537643\nCG error = 3.38704753366071\nCG error = 0.47806966030197\nCG error = 0.83063693820718\nCG error = 0.10407914602798\nDidnot converge, Residual value : 0.4302411050563448\nCG error = 1809191201.65286087989807\nCG error = 30528.61295431769031\nCG error = 410.36880422420364\nCG error = 33.62624023735062\nCG error = 1.81363087903672\nCG error = 0.26855517956802\nCG error = 0.01572767915948\nCG error = 0.00364347008115\nCG error = 0.00026425956375\nCG error = 0.00004561819059\nCG error = 0.00000353302146\nCG error = 0.00000065830433\nCG error = 0.00000005500087\nCG error = 0.00000001175910\nCG error = 0.00000000134181\nCG error = 0.00000000028057\nCG error = 0.00000000003430\nCG error = 0.00000000000619\nCG error = 0.00000000000074\nCG error = 0.00000000000010\nDidnot converge, Residual value : 1.1374537107621268e-07\nCG error = 1809191201.65287327766418\nCG error = 1.25285005834628\nCG error = 0.00001036363130\nCG error = 0.00000002019141\nCG error = 0.00000000000601\nCG error = 0.00000000000006\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 7.464999427292982e-09\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/displacement_based_fft/","title":"Linear Elasticity","text":"<p>In this example, we solve a displacement-based FFT problem for a heterogeneous material.</p> <pre><code>import jax\n\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\n\nimport jax.numpy as jnp\nfrom jax import Array\n\nimport numpy as np\n</code></pre> <pre><code>from xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.transform import FFTTransform\nfrom xpektra.scheme import FourierScheme\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    newton_krylov_solver,\n    preconditioned_conjugate_gradient,\n)\n\n\nimport equinox as eqx\nimport matplotlib.pyplot as plt\n</code></pre> <p>In order to speed up the solution, we define a preconditioner defined as</p> \\[ \\mathbb{M}(\\xi) = [ \\xi \\cdot \\mathbb{C} \\cdot \\xi ]^{-1} \\] <p>where \\(\\mathbb{C}\\) is the homogeneous elasticity tensor and \\(\\xi\\) is the wavenumber vector.</p> <pre><code>class HomogeneousPreconditioner(eqx.Module):\n    \"\"\"\n    A callable module that applies the inverse of the homogeneous\n    elasticity operator, M\u207b\u00b9 = [div(C0 : \u03b5(u))]\u207b\u00b9.\n\n    This is used as a preconditioner for the CG solver.\n    \"\"\"\n\n    M_inv: Array\n    space: SpectralSpace = eqx.field(static=True)\n    u_shape: tuple = eqx.field(static=True)\n\n    def __init__(self, space: SpectralSpace, C0: Array, u_shape: tuple):\n        self.space = space\n        self.u_shape = u_shape\n\n        dim = len(space.lengths)\n\n        # xi_vec = space.wavenumber_vector()\n        # if space.dim == 1:\n        #    meshes = [xi_vec]\n        # else:\n        #    meshes = np.meshgrid(*([xi_vec] * space.dim), indexing=\"ij\")\n        meshes = self.space.get_wavenumber_mesh()\n\n        # xi_field is our '\u03be' field, shape (N, N, d)\n        xi_field = jnp.stack(meshes, axis=-1)\n\n        # Compute the acoustic tensor field: M_il = D_j * C0_ijkl * D_k\n        M = jnp.einsum(\"...j,...k,ijkl-&gt;...il\", xi_field, xi_field, C0, optimize=True)\n\n        # Invert the K matrix at every point\n        M_reg = M + jnp.eye(dim) * 1e-12\n        M_inv = jnp.linalg.inv(M_reg)\n\n        xi_dot_xi = jnp.sum(xi_field * xi_field, axis=-1, keepdims=True)\n        self.M_inv = jnp.where((xi_dot_xi == 0)[..., None], 0.0, M_inv)\n\n    @eqx.filter_jit\n    def __call__(self, r_flat: Array) -&gt; Array:\n        \"\"\"Applies the preconditioner: z = M\u207b\u00b9 * r\"\"\"\n        r = r_flat.reshape(self.u_shape)\n        r_hat = self.space.transform.forward(r)\n\n        # z_hat = M_inv * r_hat  (z_i = K_inv_il * r_l)\n        z_hat = jnp.einsum(\"...il,...l-&gt;...i\", self.M_inv, r_hat, optimize=True)\n\n        z = self.space.transform.inverse(z_hat).real\n        return z.reshape(-1)\n</code></pre> <pre><code>N = 251\nndim = 2\nlength = 1\n\n# Create phase indicator (cylinder)\nx = np.linspace(-0.5, 0.5, N)\n\nif ndim == 3:\n    Y, X, Z = np.meshgrid(x, x, x, indexing=\"ij\")  # (N, N, N) grid\n    phase = jnp.where(X**2 + Z**2 &lt;= (0.2 / np.pi), 1.0, 0.0)  # 20% vol frac\nelse:\n    X, Y = np.meshgrid(x, x, indexing=\"ij\")  # (N, N) grid\n    phase = jnp.where(X**2 + Y**2 &lt;= (0.2 / np.pi), 1.0, 0.0)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(phase)\nplt.colorbar()\nplt.show()\n</code></pre> <p></p> <p>Similar to the examples for <code>Fourier-Galerkin</code> and <code>Moulinec-Suquet</code> tutorials, we define the <code>SpectralSpace</code> and <code>TensorOperator</code> objects.</p> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=phase.shape, transform=fft_transform\n)\nfourier_scheme = FourierScheme(space=space)\n\nop = SpectralOperator(\n    scheme=fourier_scheme,\n    space=space,\n)\n\nu_shape = make_field(dim=ndim, shape=phase.shape, rank=1).shape\neps_shape = make_field(dim=ndim, shape=phase.shape, rank=2).shape\n</code></pre> <p>Unlike <code>Fourier-Galerkin</code> and <code>Moulinec-Suquet</code> schemes, displacement-based FFT scheme doesnot require any projection operators. Since it solves the strong form of the problem, we need to define a symmetric gradient and divergence operators in Fourier space.</p> <pre><code># scheme = Fourier(space=space)\n\n# nabla = scheme.gradient_operator\n# nabla_sym = scheme.symmetric_gradient_operator\n# div = scheme.divergence_operator\n</code></pre> <p>Defining the material parameters.</p> <pre><code># Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 10.0, 1000.0\nmu1, mu2 = 0.25, 2.5\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n</code></pre> <p>Now we can construct our preconditioner. We need to define a reference tensor \\(\\mathbb{C}_0\\) and pass it to the preconditioner. The reference tensor is defined as the average of the material parameters over the domain.</p> <pre><code># --- Create a C0 reference tensor ---\nlambda0 = jnp.mean(lambdas)\nmu0 = jnp.mean(mu)\ni = jnp.eye(ndim)\nI4 = jnp.einsum(\"il,jk-&gt;ijkl\", i, i)\nI4rt = jnp.einsum(\"ik,jl-&gt;ijkl\", i, i)\nI4s = (I4 + I4rt) / 2.0\nII = jnp.einsum(\"ij,kl-&gt;ijkl\", i, i)\nC0 = lambda0 * II + 2.0 * mu0 * I4s  # C0 is shape (d,d,d,d)\n\n# --- Instantiate the Preconditioner ---\npreconditioner_fn = HomogeneousPreconditioner(space=space, C0=C0, u_shape=u_shape)\n\nkrylov_solver_fn = eqx.Partial(\n    preconditioned_conjugate_gradient, M_inv=preconditioner_fn\n)\n</code></pre>"},{"location":"examples/displacement_based_fft/#defining-the-strain-and-strain-energy-functions","title":"Defining the strain and strain energy functions.","text":"<pre><code>@eqx.filter_jit\ndef compute_strain(u: Array) -&gt; Array:\n    u = u.reshape(u_shape)\n    return op.sym_grad(u)\n\n\n@eqx.filter_jit\ndef strain_energy(eps: Array) -&gt; Array:\n    eps = eps.reshape(eps_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambdas, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre> <pre><code>class Residual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    u_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, u_flat: Array, eps_macro: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        u = u_flat.reshape(self.u_shape)\n        eps = compute_strain(u)\n        sigma = compute_stress(eps + eps_macro)\n        residual = op.div(sigma)\n        return residual.reshape(-1)\n\n\nclass Jacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    u_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, du_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n        du = du_flat.reshape(self.u_shape)\n        deps = compute_strain(du)\n        dsigma = compute_stress(deps)\n        tangent = op.div(dsigma)\n        return tangent.reshape(-1)\n</code></pre> <pre><code>du = make_field(dim=2, shape=phase.shape, rank=1)\nu = make_field(dim=2, shape=phase.shape, rank=1)\n\neps_macro = make_field(dim=2, shape=phase.shape, rank=2)\n\nresidual_fn = Residual(u_shape=u_shape)\njacobian_fn = Jacobian(u_shape=u_shape)\n\n\napplied_strains = jnp.linspace(0, 1e-2, num=5)\n\nfor inc, eps_avg in enumerate(applied_strains):\n    # solving for elasticity\n    eps_macro[:, :, 0, 0] = eps_avg\n    eps_macro[:, :, 1, 1] = eps_avg\n\n    residual_partial = eqx.Partial(residual_fn, eps_macro=eps_macro)\n\n    b = -residual_partial(u)\n\n    final_state = newton_krylov_solver(\n        state=(du, b, u),\n        gradient=residual_partial,\n        jacobian=jacobian_fn,\n        tol=1e-8,\n        max_iter=10,\n        krylov_solver=krylov_solver_fn,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n    u = final_state[2]\n\n\neps = compute_strain(u) + eps_macro\n\nsig = compute_stress(eps)\n</code></pre> <pre><code>Converged, Residual value : 0.0\nCG error = 0.00000000136012\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 3.594582014578854e-05\nCG error = 0.00000000136012\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 3.594610592034313e-05\nCG error = 0.00000000136012\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 3.5946089737220744e-05\nCG error = 0.00000000136012\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 3.594599207836797e-05\n</code></pre> <p>Let us now plot the stresses and displacement fields</p> <pre><code>from mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3), layout=\"constrained\")\ncb1 = ax1.imshow(sig.at[:, :, 0, 0].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb1, cax=cax, label=r\"$\\sigma_{xx}$\", orientation=\"horizontal\", location=\"top\"\n)\n\n\ncb2 = ax2.imshow(u.at[:, :, 1].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb2, cax=cax, label=\"Displacement\", orientation=\"horizontal\", location=\"top\"\n)\n\nax3.plot(sig.at[:, :, 0, 0].get()[:, int(N / 2)])\nax_twin = ax3.twinx()\nax_twin.plot(phase[int(N / 2), :], color=\"gray\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/gent/","title":"Gent","text":"<pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\nimport equinox as eqx\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom skimage.morphology import disk, rectangle\nimport itertools\n</code></pre> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <pre><code>import sys\n\nfrom projection_operators import compute_Ghat_4_2\nimport tensor_operators as tensor\n\nsys.path.append(\"../plot_helpers/\")\nplt.style.use([\"../plot_helpers/prl_paper.mplstyle\"])\nfrom plot_helper_for_paper import plot_contourf, plot_imshow, set_size\n</code></pre>"},{"location":"examples/gent/#constructing-a-dual-phase-rve","title":"constructing a dual phase RVE","text":"<pre><code>H, L = (199, 199)\nHmid = int(H / 2)\nLmid = int(L / 2)\nr = 49\n\nstructure = np.zeros((H, L))\nstructure[:r, -r:] += rectangle(r, r)\n\nplt.figure(figsize=(3, 3))\ncb = plt.imshow(structure, origin=\"lower\")\nplt.colorbar(cb)\n</code></pre> <pre><code>&lt;matplotlib.colorbar.Colorbar at 0x14bc89d65210&gt;\n</code></pre> <pre><code>ndim = len(structure.shape)\nN = structure.shape[0]\n\n# grid dimensions\nshape = [N, N]  # number of voxels in all directions\n</code></pre> <p>We also define certain Identity tensor for each grid point.</p> <ul> <li>\\(\\mathbf{I}\\) = 2 order Identity tensor with shape <code>(2, 2, N, N)</code> </li> <li>\\(\\mathbb{I4}\\) = 4 order Identity tensor with shape <code>(2, 2, 2, 2, N, N)</code></li> </ul> <pre><code># identity tensor (single tensor)\ni = jnp.eye(ndim)\n\n# identity tensors (grid)\nI = jnp.einsum(\"ij,xy\", i, jnp.ones([N, N]))  # 2nd order Identity tensor\nI4 = jnp.einsum(\n    \"ijkl,xy-&gt;ijklxy\", jnp.einsum(\"il,jk\", i, i), jnp.ones([N, N])\n)  # 4th order Identity tensor\nI4rt = jnp.einsum(\"ijkl,xy-&gt;ijklxy\", jnp.einsum(\"ik,jl\", i, i), jnp.ones([N, N]))\nI4s = (I4 + I4rt) / 2.0\n\nII = tensor.dyad22(I, I)\n</code></pre>"},{"location":"examples/gent/#assigning-material-parameters","title":"assigning material parameters","text":"<p>We assign material parameters to the two phases. The two phases within the RVE are denoted as - Soft = 0 - Hard = 1</p> <pre><code># material parameters + function to convert to grid of scalars\n@functools.partial(jax.jit, static_argnames=[\"soft\", \"hard\"])\ndef param(X, soft, hard):\n    return soft * jnp.ones_like(X) * (X) + hard * jnp.ones_like(X) * (1 - X)\n</code></pre> <pre><code># material parameters\nshear_modulus = {\"hard\": 50, \"soft\": 16}  # N/mm2\njm_modulus = {\"hard\": 0.2, \"soft\": 0.4}\n</code></pre> <pre><code># material parameters\n\u03bc0 = param(\n    structure, soft=shear_modulus[\"soft\"], hard=shear_modulus[\"hard\"]\n)  # shear     modulus\nJm = param(\n    structure, soft=jm_modulus[\"soft\"], hard=jm_modulus[\"hard\"]\n)  # shear     modulus\n</code></pre> <pre><code>plt.imshow(Jm, origin=\"lower\")\nplt.colorbar()\n</code></pre> <pre><code>&lt;matplotlib.colorbar.Colorbar at 0x14bc89cb4b50&gt;\n</code></pre> <p></p> <pre><code>Ghat4_2 = compute_Ghat_4_2(NN=(N,) * ndim, operator=\"fourier\", length=1.0)\n</code></pre> <pre><code># (inverse) Fourier transform (for each tensor component in each direction)\n@jax.jit\ndef fft(x):\n    return jnp.fft.fftshift(jnp.fft.fftn(jnp.fft.ifftshift(x), [N, N]))\n\n\n@jax.jit\ndef ifft(x):\n    return jnp.fft.fftshift(jnp.fft.ifftn(jnp.fft.ifftshift(x), [N, N]))\n\n\n# functions for the projection 'G', and the product 'G : K : dF'\n@jax.jit\ndef G(A2):\n    return jnp.real(ifft(tensor.ddot42(Ghat4_2, fft(A2)))).reshape(-1)\n\n\n@jax.jit\ndef K_dF(dF, K4):\n    # jax.debug.print('x={}', K4)\n    return tensor.trans2(tensor.ddot42(K4, tensor.trans2(dF.reshape(ndim, ndim, N, N))))\n\n\n@jax.jit\ndef G_K_dF(dF, K4):\n    return G(K_dF(dF, K4))\n</code></pre>"},{"location":"examples/gent/#gent-material","title":"gent material","text":"<p>The strain energy function for a <code>Gent</code> material (isotropic compresisble hyperelastic material) is given as  \\begin{align}     \\psi = -\\dfrac{\\mu}{2} \\left( J_m \\ln \\left( 1 - \\dfrac{I_1 - 3}{J_m} \\right) + 2 \\ln(J) \\right) \\end{align}</p> <p>where \\(I_1 = \\text{tr}(B) =  \\text{tr}(F^T.F)\\) \\(B\\) is the left Cauchy Green deformation gradient</p> <p>where \\(J = \\text{det}(F)\\) is the determinant of deformation gradient</p> <p>where <code>E= Green-Lagrange strain tensor</code> which can be related to the <code>deformation gradient F</code> as  \\begin{align} E = \\dfrac{1}{2}(F^{T}.F -I) \\end{align}</p> <pre><code># determinant of grid of 2nd-order tensors\n@jax.jit\ndef det2(A2):\n    return A2.at[0, 0].get() * A2.at[1, 1].get() - A2.at[0, 1].get() * A2.at[1, 0].get()\n\n\n@jax.jit\ndef left_cauchy_green_deformation_tensor(F: ArrayLike) -&gt; Array:\n    return tensor.dot22(tensor.trans2(F), F)\n\n\n@jax.jit\ndef strain_energy(F: ArrayLike) -&gt; Array:\n    B = left_cauchy_green_deformation_tensor(F)\n    J = det2(F)\n    I1 = tensor.trace2(B)\n    energy = -jnp.multiply(\n        \u03bc0 / 2.0, jnp.multiply(Jm, jnp.log(1 - jnp.divide(I1 - 3, Jm)) + 2 * jnp.log(J))\n    )\n    return energy.sum()\n\n\npiola_kirchhoff = jax.jit(jax.jacrev(strain_energy))\n</code></pre> <p>Due to the <code>geometric nonlinearity</code> in the stress-strain relationship, we use a <code>Netwon-Raphson</code> scheme combined with <code>Conjugate gradient</code> to solve for the compatible strains within the RVE.  \\begin{align}     \\Delta \\sigma_{ij} = \\dfrac{\\partial \\sigma_{ij}(F)}{\\partial F_{ij}}\\Delta F_{ij} \\end{align}</p> <pre><code>@functools.partial(jax.jit, static_argnames=[\"piola_kirchhoff\"])\ndef G_P(dF, additional, piola_kirchhoff):\n    dF = dF.reshape(ndim, ndim, N, N)\n    tangents = jax.jvp(\n        piola_kirchhoff, (additional,), (dF,)\n    )[\n        1\n    ]  ## to compute the jvp at F in the direction of dF to get the correct incremental stress\n    return G(tangents)\n</code></pre> <pre><code>@functools.partial(jax.jit, static_argnames=[\"A\", \"K\"])\ndef conjugate_gradient(A, b, additional, K, atol=1e-5):\n    b, additional = jax.device_put((b, additional))\n\n    def body_fun(state):\n        b, p, r, rsold, x = state\n        Ap = A(p, additional, K)\n        alpha = rsold / jnp.vdot(p, Ap)\n        x = x + jnp.dot(alpha, p)\n        r = r - jnp.dot(alpha, Ap)\n        rsnew = jnp.vdot(r, r)\n        p = r + (rsnew / rsold) * p\n        rsold = rsnew\n        return (b, p, r, rsold, x)\n\n    def cond_fun(state):\n        b, p, r, rsold, x = state\n        return jnp.sqrt(rsold) &gt; atol\n\n    x = jnp.zeros_like(b)\n    r = b - A(x, additional, K)\n    p = r\n    rsold = jnp.vdot(r, r)\n\n    b, p, r, rsold, x = jax.lax.while_loop(cond_fun, body_fun, (b, p, r, rsold, x))\n    return x\n</code></pre>"},{"location":"examples/gent/#newton-raphson-method","title":"newton raphson method","text":"<p>Here we define a function to solve the hyperelasticity problem using a <code>newton-raphson</code> method</p> <pre><code>@jax.jit\ndef solve_netwon_raphson(state, n):\n    dF, b, F, Fn = state\n\n    error = jnp.linalg.norm(dF) / Fn\n    jax.debug.print(\"residual={}\", error)\n\n    def true_fun(state):\n        dF, b, F, Fn = state\n\n        dF = conjugate_gradient(\n            atol=1e-8,\n            A=G_P,\n            b=b,\n            additional=F,\n            K=piola_kirchhoff,\n        )  # solve linear system using CG\n\n        dF = dF.reshape(ndim, ndim, N, N)\n        F = jax.lax.add(F, dF)  # update DOFs (array -&gt; tens.grid)\n        P = piola_kirchhoff(F)  # new residual stress\n        b = -G(P)  # convert residual stress to residual\n\n        return (dF, b, F, Fn)\n\n    def false_fun(state):\n        return state\n\n    return jax.lax.cond(error &gt; 1e-5, true_fun, false_fun, state), n\n</code></pre>"},{"location":"examples/gent/#solving-for-a-given-loaded-state","title":"solving for a given loaded state","text":"<pre><code>F = jnp.array(I, copy=True)\nP = piola_kirchhoff(F)\n\n# set macroscopic loading\nDbarF = jnp.zeros([ndim, ndim, N, N])\nDbarF = DbarF.at[0, 1].set(1e-1)\n\n# initial residual: distribute \"barF\" over grid using \"K4\"\nb = -G_P(DbarF, F, piola_kirchhoff)\nF = jax.lax.add(F, DbarF)\nFn = jnp.linalg.norm(F)\n</code></pre> <pre><code>state = (DbarF, b, F, Fn)\ninitial_state = jax.device_put(state)\n</code></pre> <pre><code>final_state, xs = jax.lax.scan(\n    solve_netwon_raphson, init=initial_state, xs=jnp.arange(0, 10)\n)\n</code></pre> <pre><code>residual=0.0705345615858598\nresidual=0.008470035538537467\nresidual=0.0015565804971452296\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\nresidual=7.856409318335205e-06\n</code></pre> <pre><code>plt.imshow(final_state[2].at[0, 1].get(), origin=\"lower\")\nplt.colorbar()\n</code></pre> <pre><code>&lt;matplotlib.colorbar.Colorbar at 0x14bc7758cb50&gt;\n</code></pre> <pre><code>@jax.jit\ndef local_constitutive_update(macro_strain):\n    # ----------------------------- NEWTON ITERATIONS -----------------------------\n    # initialize stress and strain tensor                         [grid of tensors]\n    # eps      = jnp.zeros([ndim,ndim,N,N])\n    eps = jnp.array(I, copy=True)\n    # set macroscopic loading\n    DE = jnp.zeros([ndim, ndim, N, N])\n    DE = DE.at[0, 0].set(macro_strain[0, 0])\n    DE = DE.at[1, 1].set(macro_strain[1, 1])\n    DE = DE.at[0, 1].set(macro_strain[0, 1])\n    DE = DE.at[1, 0].set(macro_strain[1, 0])\n\n    # initial residual: distribute \"DE\" over grid using \"K4\"\n    b = -G_P(DE, eps, piola_kirchhoff)\n    eps = jax.lax.add(eps, DE)\n    En = jnp.linalg.norm(eps)\n\n    state = (DE, b, eps, En)\n    initial_state = jax.device_put(state)\n\n    final_state, xs = jax.lax.scan(\n        solve_netwon_raphson, init=initial_state, xs=jnp.arange(0, 10)\n    )\n\n    DE, b, eps, En = final_state\n    P = piola_kirchhoff(eps)\n\n    # get the macro stress\n    macro_sigma = jnp.array(\n        [\n            jnp.mean(P.at[0, 0].get()),\n            jnp.mean(P.at[1, 1].get()),\n            jnp.mean(P.at[0, 1].get()),\n        ]\n    )\n\n    return jnp.array(\n        [\n            [macro_sigma.at[0].get(), macro_sigma.at[2].get() / 2.0],\n            [macro_sigma.at[2].get() / 2.0, macro_sigma.at[1].get()],\n        ]\n    ), (macro_sigma, P, eps)\n</code></pre> <pre><code>tangent_operator_and_state = jax.jacfwd(\n    local_constitutive_update, argnums=0, has_aux=True\n)\n</code></pre> <pre><code>deps = jnp.array([[1e-3, 0], [0, 2e-3]])\n</code></pre> <pre><code>import timeit\n</code></pre> <pre><code>start = timeit.default_timer()\ntangent, state = tangent_operator_and_state(deps)\nprint(timeit.default_timer() - start)\n</code></pre> <pre><code>residual=0.0015787704773174971\nresidual=0.00026910167792174754\nresidual=0.001276752994205467\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\nresidual=5.049238385397511e-06\n6.844096690008882\n</code></pre> <pre><code>tangent\n</code></pre> <pre><code>Array([[[[ 3.11166606e+01, -3.87558978e-17],\n         [-1.36363344e-16,  1.33568329e+01]],\n\n        [[-1.43540362e-18,  4.02346502e+00],\n         [ 4.82959902e+00, -7.17701811e-19]]],\n\n\n       [[[-1.43540362e-18,  4.02346502e+00],\n         [ 4.82959902e+00, -7.17701811e-19]],\n\n        [[ 1.33568329e+01, -7.03347775e-17],\n         [-1.30621730e-16,  3.11245167e+01]]]], dtype=float64)\n</code></pre> <pre><code>state[0]\n</code></pre> <pre><code>Array([-1.62359708e+00, -1.60583333e+00, -3.81279087e-19], dtype=float64)\n</code></pre> <pre><code>plt.imshow(state[1].at[0, 0].get(), origin=\"lower\")\nplt.colorbar()\n</code></pre> <pre><code>&lt;matplotlib.colorbar.Colorbar at 0x15027e4c7910&gt;\n</code></pre> <pre><code>tangents = []\ndeformations = np.linspace(1e-4, 1e-1, num=10)\nfor dep in deformations:\n    deps = jnp.array([dep, dep / 10.0, 0])\n    tangent, state = tangent_operator_and_state(deps)\n    tangents.append(tangent)\n</code></pre> <pre><code>residual=7.105944367641367e-05\nresidual=1.1254206496892181e-05\nresidual=0.0012846588038883855\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=4.994098703763459e-06\nresidual=0.007910268322101562\nresidual=0.001228210428898748\nresidual=0.001265443412756214\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=5.341406599003363e-06\nresidual=0.015654348281605543\nresidual=0.002379548977299753\nresidual=0.0012826900693592355\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=6.030296584612204e-06\nresidual=0.023304471799337402\nresidual=0.003462975697077963\nresidual=0.0013358251586461228\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=7.164056301436735e-06\nresidual=0.030861809464007354\nresidual=0.004476473607398727\nresidual=0.0014242115496464845\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=8.892672791652492e-06\nresidual=0.03832752904243944\nresidual=0.0054183106644449626\nresidual=0.001547100378456015\nresidual=1.1425368977391468e-05\nresidual=6.755584977595293e-10\nresidual=6.755584977595293e-10\nresidual=6.755584977595293e-10\nresidual=6.755584977595293e-10\nresidual=6.755584977595293e-10\nresidual=6.755584977595293e-10\nresidual=0.045702794609239865\nresidual=0.006287046116837518\nresidual=0.001703603894744631\nresidual=1.5043993749906706e-05\nresidual=1.2745002806367327e-09\nresidual=1.2745002806367327e-09\nresidual=1.2745002806367327e-09\nresidual=1.2745002806367327e-09\nresidual=1.2745002806367327e-09\nresidual=1.2745002806367327e-09\nresidual=0.052988765736600496\nresidual=0.007081535415543497\nresidual=0.001892702062825208\nresidual=2.0116950452922185e-05\nresidual=2.4761875686840024e-09\nresidual=2.4761875686840024e-09\nresidual=2.4761875686840024e-09\nresidual=2.4761875686840024e-09\nresidual=2.4761875686840024e-09\nresidual=2.4761875686840024e-09\nresidual=0.06018659674136359\nresidual=0.007800933661451986\nresidual=0.0021132751259526497\nresidual=2.7113417615227308e-05\nresidual=4.883446763811611e-09\nresidual=4.883446763811611e-09\nresidual=4.883446763811611e-09\nresidual=4.883446763811611e-09\nresidual=4.883446763811611e-09\nresidual=4.883446763811611e-09\nresidual=0.06729743598654882\nresidual=0.008444697595858062\nresidual=0.0023641478359727394\nresidual=3.6617653213283884e-05\nresidual=9.667248978383054e-09\nresidual=9.667248978383054e-09\nresidual=9.667248978383054e-09\nresidual=9.667248978383054e-09\nresidual=9.667248978383054e-09\nresidual=9.667248978383054e-09\n</code></pre> <pre><code>plt.figure(figsize=(4, 4))\nfor i in range(0, 3):\n    for j in range(0, 3):\n        C = [tang[i, j] for tang in tangents]\n        plt.plot(deformations, C, marker=\"o\", label=f\"C{i}{j}\", markeredgecolor=\"k\")\n\nplt.ylabel(r\"$\\text{Stiffness tensor}$\")\nplt.xlabel(r\"$\\varepsilon$\")\nplt.legend()\nplt.savefig(\"./figs/paper_gent_tangent_stiffness.pdf\", dpi=200)\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/j2_plasticity/","title":"J2 plasticity","text":"<pre><code>import jax\njax.config.update(\"jax_enable_x64\", True)\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\n\nimport jax.numpy as jnp\nfrom jax import Array\nimport numpy as np\nimport equinox as eqx\nimport matplotlib.pyplot as plt\nfrom functools import partial\n</code></pre> <pre><code>from xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.transform import FFTTransform\nfrom xpektra.solvers.nonlinear import newton_krylov_solver, conjugate_gradient_while\n</code></pre> <pre><code>import random\n\nrandom.seed(1)\n\n\ndef place_circle(matrix, n, r, x_center, y_center):\n    for i in range(n):\n        for j in range(n):\n            if (i - x_center) ** 2 + (j - y_center) ** 2 &lt;= r**2:\n                matrix[i][j] = 1\n\n\ndef generate_matrix_with_circles(n, x, r):\n    if r &gt;= n:\n        raise ValueError(\"Radius r must be less than the size of the matrix n\")\n\n    matrix = np.zeros((n, n), dtype=int)\n    placed_circles = 0\n\n    while placed_circles &lt; x:\n        x_center = random.randint(0, n - 1)\n        y_center = random.randint(0, n - 1)\n\n        # Check if the circle fits within the matrix bounds\n        if (\n            x_center + r &lt; n\n            and y_center + r &lt; n\n            and x_center - r &gt;= 0\n            and y_center - r &gt;= 0\n        ):\n            previous_matrix = matrix.copy()\n            place_circle(matrix, n, r, x_center, y_center)\n            if not np.array_equal(previous_matrix, matrix):\n                placed_circles += 1\n\n    return matrix\n\nN = 199\nndim = 2\nlength = 1.0\n\nx = 10\nr = 20\nstructure = generate_matrix_with_circles(N, x, r)\n\n\ncb = plt.imshow(structure, cmap='viridis')\nplt.colorbar(cb)\nplt.show()\n</code></pre> <pre><code># Helper to map properties to grid\ndef map_prop(structure, val_soft, val_hard):\n    return val_hard * structure + val_soft * (1 - structure)\n\n\n# Properties\nphase_contrast = 2.0\nK_field = map_prop(structure, 0.833, phase_contrast * 0.833)\nmu_field = map_prop(structure, 0.386, phase_contrast * 0.386)\nH_field = map_prop(structure, 0.01, phase_contrast * 0.01)  # Normalized\nsigma_y_field = map_prop(structure, 0.003, phase_contrast * 0.003)  # Normalized\nn_exponent = 1.0\n</code></pre> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(lengths=(length, length), shape=(N, N), transform=fft_transform)\n\nscheme = RotatedDifference(space=space)\nop = SpectralOperator(scheme=scheme, space=space)\n\nGhat = GalerkinProjection(scheme=scheme)\n\ndofs_shape = make_field(dim=ndim, shape=structure.shape, rank=2).shape\n</code></pre> <pre><code># Pre-compute Identity Tensors for the grid\n# I2: (N,N,2,2), I4_dev: (N,N,2,2,2,2)\n\ni = jnp.eye(ndim)\nI = make_field(dim=ndim, shape=structure.shape, rank=ndim) * i  # Broadcasted Identity\nII = op.dyad(I, I)  # Fourth-order Identity\n\n# I2 = jnp.eye(ndim) + jnp.zeros(space.shape + (ndim, ndim))  # Broadcast\n# I4_sym = op.dyad(I2, I2)  # Placeholder, construct proper I4s if needed\n\n# Or better, just implement the math directly in the material class using tensor_op\n\n# --- 4. J2 PLASTICITY MATERIAL MODEL ---\n\n\n\nclass J2Plasticity(eqx.Module):\n    \"\"\"\n    Encapsulates the J2 Plasticity constitutive law and return mapping.\n    \"\"\"\n\n    K: jax.Array\n    mu: jax.Array\n    H: jax.Array\n    sigma_y: jax.Array\n    n: float\n\n    def yield_stress(self, ep: jax.Array) -&gt; jax.Array:\n        return self.sigma_y + self.H * (ep**self.n)\n\n    @eqx.filter_jit\n    def compute_response(\n        self, eps_total: jax.Array, state_prev: tuple[jax.Array, ...]\n    ) -&gt; tuple:\n        \"\"\"\n        Computes stress and new state variables given total strain and history.\n        state_prev = (eps_total_t, eps_elastic_t, ep_t)\n        \"\"\"\n        eps_t, epse_t, ep_t = state_prev\n\n        # Trial State (assume elastic step)\n        # Delta eps = eps_total - eps_t\n        # Trial elastic strain = old elastic strain + Delta eps\n        epse_trial = epse_t + (eps_total - eps_t)\n        jax.debug.print(\"epse_trial: {}\", epse_trial.shape)\n\n        # Volumetric / Deviatoric Split, 2D plane strain\n        trace_epse = op.trace(epse_trial)\n        epse_dev = epse_trial - (trace_epse[..., None, None] / 2.0) * jnp.eye(2)\n\n        jax.debug.print(\"trace_epse: {}\", epse_dev.shape)\n\n        # Note: Be careful with 2D trace. If plane strain, tr=e11+e22.\n        # If plane stress, e33 is non-zero. Assuming plane strain for simplicity.\n\n        # Trial Stress\n        # sigma_vol = K * trace_epse * I\n        # sigma_dev = 2 * mu * epse_dev\n        sigma_vol = self.K[..., None, None] * trace_epse[..., None, None] * jnp.eye(2)\n        sigma_dev = 2.0 * self.mu[..., None, None] * epse_dev\n        sigma_trial = sigma_vol + sigma_dev\n\n        # Mises Stress\n        # sig_eq = sqrt(3/2 * s:s)\n        norm_s = jnp.sqrt(op.ddot(sigma_dev, sigma_dev))\n        sig_eq_trial = jnp.sqrt(1.5) * norm_s\n\n        # 2. Check Yield Condition\n        sig_y_current = self.yield_stress(ep_t)\n        phi = sig_eq_trial - sig_y_current\n\n        # 3. Return Mapping (if plastic)\n        # Mask for plastic points\n        is_plastic = phi &gt; 0\n\n        # Plastic Multiplier Delta_gamma\n        # Denom = 3*mu + H\n        denom = 3.0 * self.mu + self.H  # (Linear hardening H' = H)\n        d_gamma = jnp.where(is_plastic, phi / denom, 0.0)\n\n        # Update State\n        # Normal vector n = s_trial / |s_trial|\n        # s_new = s_trial - 2*mu*d_gamma * n\n        # This simplifies to scaling s_trial\n        scale_factor = jnp.where(\n            is_plastic, 1.0 - (3.0 * self.mu * d_gamma) / sig_eq_trial, 1.0\n        )\n\n        sigma_dev_new = sigma_dev * scale_factor[..., None, None]\n        sigma_new = sigma_vol + sigma_dev_new\n\n        # Update plastic strain\n        ep_new = ep_t + d_gamma\n\n        # Update elastic strain (back-calculate from stress)\n        # eps_e_new = eps_e_trial - d_gamma * n * sqrt(3/2) ...\n        # Easier: eps_e_new = C_inv : sigma_new\n        # Or just update deviatoric part\n        epse_dev_new = epse_dev * scale_factor[..., None, None]\n        epse_vol_new = trace_epse[..., None, None] * jnp.eye(2)  # Volumetric is elastic\n        epse_new = epse_dev_new + epse_vol_new\n\n        return sigma_new, (eps_total, epse_new, ep_new)\n\n\n# Instantiate Material\nmaterial = J2Plasticity(K_field, mu_field, H_field, sigma_y_field, n_exponent)\n\n# --- 5. RESIDUAL &amp; JACOBIAN ---\n\n\nclass PlasticityResidual(eqx.Module):\n    material: J2Plasticity\n    state_prev: tuple  # (eps_t, epse_t, ep_t)\n    dofs_shape: tuple = eqx.field(static=True)\n\n    def __call__(self, eps_total_flat):\n        # Reshape\n        eps_total = eps_total_flat.reshape(self.dofs_shape)\n\n        # Compute Stress (Physics)\n        # We discard the new state here, we only need stress for residual\n        sigma, _ = self.material.compute_response(eps_total, self.state_prev)\n\n        # Compute Residual (Equilibrium)\n        sigma_hat = op.forward(sigma)\n        res_hat = Ghat.project(sigma_hat)\n        res = op.inverse(res_hat).real\n        return res.reshape(-1)\n\n\nclass PlasticityJacobian(eqx.Module):\n    residual_fn: PlasticityResidual  # Holds all necessary data\n\n    def __call__(self, deps_flat):\n        # JAX JVP does the heavy lifting!\n        # It automatically linearizes the return mapping algorithm\n        # to give the Consistent Algorithmic Tangent Operator.\n\n        # We differentiate residual_fn w.r.t its input (eps_total)\n        # evaluated at the current guess (which is baked into residual_fn if we used Partial,\n        # but here we need the current 'eps' point).\n\n        # ISSUE: Jacobian needs the current 'eps' point to evaluate the tangent.\n        # The solver passes 'deps', assuming J(eps) * deps.\n        # We need to refactor slightly to pass 'eps' into the Jacobian constructor\n        # or use the 'linearize' approach in the solver.\n        pass\n\n\n# --- 6. MAIN SIMULATION LOOP ---\n\n# Initialize Fields\n# Layout: (N, N, 2, 2)\neps_total = make_field(dim=ndim, shape=structure.shape, rank=2)\neps_elastic = make_field(dim=ndim, shape=structure.shape, rank=2)\nep_accum = make_field(dim=ndim, shape=structure.shape, rank=0)  # Scalar plastic strain\nstate_current = (eps_total, eps_elastic, ep_accum)\n\n# History storage\nstress_history = []\n\n# Load steps\nn_steps = 20\nmax_strain = 0.02\nstrain_steps = jnp.linspace(0, max_strain, n_steps)\n\neps_macro_inc = make_field(dim=ndim, shape=structure.shape, rank=2)\n\nprint(\"Starting Plasticity Simulation...\")\n\nfor step, eps_val in enumerate(strain_steps[1:]):\n    # 1. Define Macroscopic Strain Increment\n    # Pure shear loading\n    delta_eps = eps_val - strain_steps[step]\n    eps_macro_inc[..., 0, 1] = delta_eps\n    eps_macro_inc[..., 1, 0] = delta_eps\n\n    # Predictor (Initial Guess): eps_new = eps_old + deps_macro\n    eps_guess = state_current[0] + eps_macro_inc\n\n    # 2. Setup Solver Functions\n    # We bind the *previous* state history to the residual function\n    residual_fn = PlasticityResidual(material, state_current, eps_guess.shape)\n\n    # 3. Solve Equilibrium (Newton-Krylov)\n    # The solver needs a function f(x) -&gt; b and a linear operator J(dx) -&gt; db\n    # We use jax.linearize to get the Jacobian at the current guess 'x'\n\n    # Initial residual\n    b0 = -residual_fn(eps_guess.reshape(-1))\n\n    # Update guess\n    eps_iter = eps_guess\n\n    # Newton Loop (Manual or use xpektra solver)\n    for i in range(10):  # Newton iterations\n        # Linearize residual at current eps_iter\n        # val is residual(eps_iter), lin_fn is the Jacobian operator J(dx)\n        val, lin_fn = jax.linearize(residual_fn, eps_iter.reshape(-1))\n\n        if jnp.linalg.norm(val) &lt; 1e-8:\n            print(f\"Step {step}: Converged in {i} iterations.\")\n            break\n\n        # Solve J * dx = -val using CG\n        dx, _ = conjugate_gradient_while(lin_fn, -val, max_iter=50, atol=1e-5)\n\n        # Update\n        eps_iter = eps_iter + dx.reshape(eps_iter.shape)\n\n    # 4. Update State History\n    # Now we call the material one last time with the converged strain\n    # to get the official new internal variables\n    final_sigma, state_current = material.compute_response(eps_iter, state_current)\n\n    # Store results\n    avg_stress = jnp.mean(final_sigma, axis=(0, 1))\n    stress_history.append(avg_stress[0, 1])\n\n# Plot\nplt.plot(strain_steps[1:], stress_history, \"-o\")\nplt.xlabel(\"Macroscopic Shear Strain\")\nplt.ylabel(\"Macroscopic Shear Stress\")\nplt.title(\"J2 Plasticity: Stress-Strain Curve\")\nplt.grid()\nplt.show()\n</code></pre> <pre><code>Starting Plasticity Simulation...\n</code></pre> <pre><code>epse_trial: (Array(199, dtype=int64), Array(199, dtype=int64), Array(2, dtype=int64), Array(2, dtype=int64))\ntrace_epse: (Array(199, dtype=int64), Array(199, dtype=int64), Array(2, dtype=int64), Array(2, dtype=int64))\nepse_trial: (Array(199, dtype=int64), Array(199, dtype=int64), Array(2, dtype=int64), Array(2, dtype=int64))\ntrace_epse: (Array(199, dtype=int64), Array(199, dtype=int64), Array(2, dtype=int64), Array(2, dtype=int64))\n</code></pre> <pre><code>---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[19], line 207\n    204     break\n    206 # Solve J * dx = -val using CG\n--&gt; 207 dx, _ = conjugate_gradient_while(lin_fn, -val, max_iter=50, atol=1e-5)\n    209 # Update\n    210 eps_iter = eps_iter + dx.reshape(eps_iter.shape)\n\n    [... skipping hidden 1 frame]\n\nFile ~/Documents/dev/spectralsolvers/.venv/lib/python3.12/site-packages/equinox/_jit.py:263, in _call(jit_wrapper, is_lower, args, kwargs)\n    259         marker, _, _ = out = jit_wrapper._cached(\n    260             dynamic_donate, dynamic_nodonate, static\n    261         )\n    262 else:\n--&gt; 263     marker, _, _ = out = jit_wrapper._cached(\n    264         dynamic_donate, dynamic_nodonate, static\n    265     )\n    266 # We need to include the explicit `isinstance(marker, jax.Array)` check due\n    267 # to https://github.com/patrick-kidger/equinox/issues/988\n    268 if not isinstance(marker, jax.core.Tracer) and isinstance(\n    269     marker, jax.Array\n    270 ):\n\nValueError: Non-hashable static arguments are not supported. An error occurred while trying to hash an object of type &lt;class 'tuple'&gt;, (((&lt;function conjugate_gradient_while at 0x7012d45d6c00&gt;,), PyTreeDef(*)), ((None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, TypedNdArray([[[ 0.00000000e+00 +0.j        ,\n                 0.00000000e+00 +0.j        ],\n               [ 0.00000000e+00 +0.j        ,\n                -9.91837639e-02 +6.2821414j ],\n               [ 0.00000000e+00 +0.j        ,\n                -3.96636187e-01+12.55802063j],\n               ...,\n               [ 0.00000000e+00 +0.j        ,\n                -8.92060762e-01-18.82138175j],\n               [ 0.00000000e+00 +0.j        ,\n                -3.96636187e-01-12.55802063j],\n               [ 0.00000000e+00 +0.j        ,\n                -9.91837639e-02 -6.2821414j ]],\n\n              [[-9.91837639e-02 +6.2821414j ,\n                 0.00000000e+00 +0.j        ],\n               [-1.98318094e-01 +6.27901032j,\n                -1.98318094e-01 +6.27901032j],\n               [-2.97304170e-01 +6.27275126j,\n                -5.94756593e-01+12.54863049j],\n               ...,\n               [ 1.98120406e-01 +6.27275126j,\n                -5.94756593e-01-18.83077189j],\n               [ 9.91343296e-02 +6.27901032j,\n                -1.98318094e-01-12.56115172j],\n               [ 1.64497329e-18 +6.2821414j ,\n                -1.64497329e-18 -6.2821414j ]],\n\n              [[-3.96636187e-01+12.55802063j,\n                 0.00000000e+00 +0.j        ],\n               [-5.94756593e-01+12.54863049j,\n                -2.97304170e-01 +6.27275126j],\n               [-7.92481820e-01+12.53299065j,\n                -7.92481820e-01+12.53299065j],\n               ...,\n               [ 1.98120406e-01+12.54863049j,\n                -2.97304170e-01-18.83077189j],\n               [ 2.03607527e-17+12.55802063j,\n                -2.03607527e-17-12.55802063j],\n               [-1.98318094e-01+12.56115172j,\n                 9.91343296e-02 -6.27901032j]],\n\n              ...,\n\n              [[-8.92060762e-01-18.82138175j,\n                 0.00000000e+00 +0.j        ],\n               [-5.94756593e-01-18.83077189j,\n                 1.98120406e-01 +6.27275126j],\n               [-2.97304170e-01-18.83077189j,\n                 1.98120406e-01+12.54863049j],\n               ...,\n               [-1.78012267e+00-18.73701082j,\n                -1.78012267e+00-18.73701082j],\n               [-1.48503935e+00-18.77447784j,\n                -9.89614772e-01-12.51111672j],\n               [-1.18892032e+00-18.80261083j,\n                -3.96043321e-01 -6.26337048j]],\n\n              [[-3.96636187e-01-12.55802063j,\n                 0.00000000e+00 +0.j        ],\n               [-1.98318094e-01-12.56115172j,\n                 9.91343296e-02 +6.27901032j],\n               [ 2.03607527e-17-12.55802063j,\n                -2.03607527e-17+12.55802063j],\n               ...,\n               [-9.89614772e-01-12.51111672j,\n                -1.48503935e+00-18.77447784j],\n               [-7.92481820e-01-12.53299065j,\n                -7.92481820e-01-12.53299065j],\n               [-5.94756593e-01-12.54863049j,\n                -2.97304170e-01 -6.27275126j]],\n\n              [[-9.91837639e-02 -6.2821414j ,\n                 0.00000000e+00 +0.j        ],\n               [ 1.64497329e-18 -6.2821414j ,\n                -1.64497329e-18 +6.2821414j ],\n               [ 9.91343296e-02 -6.27901032j,\n                -1.98318094e-01+12.56115172j],\n               ...,\n               [-3.96043321e-01 -6.26337048j,\n                -1.18892032e+00-18.80261083j],\n               [-2.97304170e-01 -6.27275126j,\n                -5.94756593e-01-12.54863049j],\n               [-1.98318094e-01 -6.27901032j,\n                -1.98318094e-01 -6.27901032j]]], dtype=complex128)), PyTreeDef(CustomNode(Partial[_HashableCallableShim(functools.partial(&lt;function _lift_linearized at 0x7012d6518040&gt;, let _where = { lambda ; a:bool[199,199] b:f64[199,199] c:f64[199,199]. let\n    d:f64[199,199] = select_n a b c\n  in (d,) } in\n{ lambda e:bool[199,199,2,2] f:f64[199,199,2,2] g:f64[1,1,2,2] h:f64[199,199,1,1]\n    i:f64[1,1,2,2] j:f64[199,199,1,1] k:f64[199,199,2,2] l:f64[199,199] m:f64[] n:f64[199,199]\n    o:bool[199,199] p:f64[199,199] q:f64[199,199] r:f64[199,199] s:f64[199,199] t:f64[199,199]\n    u:f64[199,199] v:f64[199,199,1,1] w:c128[199,199,2] x:c128[199,199,2]; y:f64[158404]. let\n    z:f64[199,199,2,2] = reshape[\n      dimensions=None\n      new_sizes=(199, 199, 2, 2)\n      sharding=None\n    ] y\n    ba:f64[199,199,2,2] = jit[\n      name=compute_response\n      jaxpr={ lambda ; e:bool[199,199,2,2] f:f64[199,199,2,2] g:f64[1,1,2,2] h:f64[199,199,1,1]\n          i:f64[1,1,2,2] j:f64[199,199,1,1] k:f64[199,199,2,2] l:f64[199,199] m:f64[]\n          n:f64[199,199] o:bool[199,199] p:f64[199,199] q:f64[199,199] r:f64[199,199]\n          s:f64[199,199] t:f64[199,199] u:f64[199,199] v:f64[199,199,1,1] z:f64[199,199,2,2]. let\n          bb:f64[199,199] = jit[\n            name=trace\n            jaxpr={ lambda ; e:bool[199,199,2,2] f:f64[199,199,2,2] z:f64[199,199,2,2]. let\n                bb:f64[199,199] = jit[\n                  name=trace\n                  jaxpr={ lambda ; e:bool[199,199,2,2] f:f64[199,199,2,2] z:f64[199,199,2,2]. let\n                      bc:f64[199,199,2,2] = select_n e f z\n                      bb:f64[199,199] = reduce_sum[\n                        axes=(2, 3)\n                        out_sharding=None\n                      ] bc\n                    in (bb,) }\n                ] e f z\n              in (bb,) }\n          ] e f z\n          bd:f64[199,199,1,1] = broadcast_in_dim[\n            broadcast_dimensions=(0, 1)\n            shape=(199, 199, 1, 1)\n            sharding=None\n          ] bb\n          be:f64[199,199,1,1] = div bd 2.0:f64[]\n          bf:f64[199,199,2,2] = mul be g\n          bg:f64[199,199,2,2] = sub z bf\n          bh:f64[199,199,1,1] = broadcast_in_dim[\n            broadcast_dimensions=(0, 1)\n            shape=(199, 199, 1, 1)\n            sharding=None\n          ] bb\n          bi:f64[199,199,1,1] = mul h bh\n          bj:f64[199,199,2,2] = mul bi i\n          bk:f64[199,199,2,2] = mul j bg\n          bl:f64[199,199] = jit[\n            name=ddot\n            jaxpr={ lambda ; k:f64[199,199,2,2] bm:f64[199,199,2,2] bk:f64[199,199,2,2]\n                bn:f64[199,199,2,2]. let\n                bl:f64[199,199] = jit[\n                  name=ddot\n                  jaxpr={ lambda ; k:f64[199,199,2,2] bm:f64[199,199,2,2] bk:f64[199,199,2,2]\n                      bn:f64[199,199,2,2]. let\n                      bo:f64[199,199] = dot_general[\n                        dimension_numbers=(([2, 3], [3, 2]), ([0, 1], [0, 1]))\n                        preferred_element_type=float64\n                      ] bk k\n                      bp:f64[199,199] = dot_general[\n                        dimension_numbers=(([2, 3], [3, 2]), ([0, 1], [0, 1]))\n                        preferred_element_type=float64\n                      ] bm bn\n                      bl:f64[199,199] = add_any bo bp\n                    in (bl,) }\n                ] k bm bk bn\n              in (bl,) }\n          ] k k bk bk\n          bq:f64[199,199] = mul bl l\n          br:f64[199,199] = mul m bq\n          bs:f64[199,199] = div br n\n          bt:f64[199,199] = jit[name=_where jaxpr=_where] o p bs\n          bu:f64[199,199] = mul q bt\n          bv:f64[199,199] = div bu r\n          bw:f64[199,199] = neg br\n          bx:f64[199,199] = mul bw s\n          by:f64[199,199] = mul bx t\n          bz:f64[199,199] = add_any bv by\n          ca:f64[199,199] = neg bz\n          cb:f64[199,199] = jit[name=_where jaxpr=_where] o u ca\n          cc:f64[199,199,1,1] = broadcast_in_dim[\n            broadcast_dimensions=(0, 1)\n            shape=(199, 199, 1, 1)\n            sharding=None\n          ] cb\n          cd:f64[199,199,2,2] = mul bk v\n          ce:f64[199,199,2,2] = mul k cc\n          cf:f64[199,199,2,2] = add_any cd ce\n          ba:f64[199,199,2,2] = add bj cf\n        in (ba,) }\n    ] e f g h i j k l m n o p q r s t u v z\n    cg:c128[199,199,2,2] = jit[\n      name=forward\n      jaxpr={ lambda ; ba:f64[199,199,2,2]. let\n          cg:c128[199,199,2,2] = jit[\n            name=forward\n            jaxpr={ lambda ; ba:f64[199,199,2,2]. let\n                ch:f64[2,2,199,199] = transpose[permutation=(2, 3, 0, 1)] ba\n                ci:c128[2,2,199,199] = jit[\n                  name=fft\n                  jaxpr={ lambda ; ch:f64[2,2,199,199]. let\n                      cj:c128[2,2,199,199] = convert_element_type[\n                        new_dtype=complex128\n                        weak_type=False\n                      ] ch\n                      ci:c128[2,2,199,199] = fft[\n                        fft_lengths=(199, 199)\n                        fft_type=0\n                      ] cj\n                    in (ci,) }\n                ] ch\n                cg:c128[199,199,2,2] = transpose[permutation=(2, 3, 0, 1)] ci\n              in (cg,) }\n          ] ba\n        in (cg,) }\n    ] ba\n    ck:c128[199,199,2,2] = jit[\n      name=project\n      jaxpr={ lambda ; w:c128[199,199,2] x:c128[199,199,2] cg:c128[199,199,2,2]. let\n          cl:c128[199,199,2] = dot_general[\n            dimension_numbers=(([2], [3]), ([0, 1], [0, 1]))\n            preferred_element_type=complex128\n          ] w cg\n          ck:c128[199,199,2,2] = dot_general[\n            dimension_numbers=(([], []), ([0, 1], [0, 1]))\n            preferred_element_type=complex128\n          ] cl x\n        in (ck,) }\n    ] w x cg\n    cm:f64[199,199,2,2] = jit[\n      name=inverse\n      jaxpr={ lambda ; ck:c128[199,199,2,2]. let\n          cn:c128[199,199,2,2] = jit[\n            name=inverse\n            jaxpr={ lambda ; ck:c128[199,199,2,2]. let\n                co:c128[2,2,199,199] = transpose[permutation=(2, 3, 0, 1)] ck\n                cp:c128[2,2,199,199] = jit[\n                  name=fft\n                  jaxpr={ lambda ; co:c128[2,2,199,199]. let\n                      cp:c128[2,2,199,199] = fft[\n                        fft_lengths=(199, 199)\n                        fft_type=1\n                      ] co\n                    in (cp,) }\n                ] co\n                cn:c128[199,199,2,2] = transpose[permutation=(2, 3, 0, 1)] cp\n              in (cn,) }\n          ] ck\n          cm:f64[199,199,2,2] = real cn\n        in (cm,) }\n    ] ck\n    cq:f64[158404] = reshape[dimensions=None new_sizes=(158404,) sharding=None] cm\n  in (cq,) }, [ShapedArray(float64[158404])], (PyTreeDef((*,)), PyTreeDef(*)), [(ShapedArray(float64[158404]), None)]))], [([*, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *],), {}]))), ((None, 1e-05, 50), PyTreeDef(((*, *, *, None), {})))). The error was:\nTypeError: unhashable type: 'TypedNdArray'\n</code></pre> <pre><code>ep_accum.shape\n</code></pre> <pre><code>(199, 199, 2)\n</code></pre> <pre><code>\n</code></pre> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nimport jax.numpy as jnp\nimport numpy as np\n</code></pre> <pre><code>from functools import partial\n\nimport matplotlib.pyplot as plt\nfrom skimage.morphology import disk, ellipse, rectangle\nfrom spectralsolver import (\n    DifferentialMode,\n    SpectralSpace,\n    TensorOperator,\n    make_field,\n)\nfrom spectralsolver.operators import fourier_galerkin\nfrom typing import Callable\n</code></pre> <p>In this notebook, we implement the small-strain <code>J2</code> plasticity. We use the automatic differentiation to compute the alogriothmic tangent stiffness matrix (which ia function of bbothe elastic strain and plastic strain and yield function). It is necessary for <code>Newton-Raphson</code> iteration. </p>"},{"location":"examples/j2_plasticity/#constructing-an-rve","title":"constructing an RVE","text":"<pre><code>import random\n\nrandom.seed(1)\n\n\ndef place_circle(matrix, n, r, x_center, y_center):\n    for i in range(n):\n        for j in range(n):\n            if (i - x_center) ** 2 + (j - y_center) ** 2 &lt;= r**2:\n                matrix[i][j] = 1\n\n\ndef generate_matrix_with_circles(n, x, r):\n    if r &gt;= n:\n        raise ValueError(\"Radius r must be less than the size of the matrix n\")\n\n    matrix = np.zeros((n, n), dtype=int)\n    placed_circles = 0\n\n    while placed_circles &lt; x:\n        x_center = random.randint(0, n - 1)\n        y_center = random.randint(0, n - 1)\n\n        # Check if the circle fits within the matrix bounds\n        if (\n            x_center + r &lt; n\n            and y_center + r &lt; n\n            and x_center - r &gt;= 0\n            and y_center - r &gt;= 0\n        ):\n            previous_matrix = matrix.copy()\n            place_circle(matrix, n, r, x_center, y_center)\n            if not np.array_equal(previous_matrix, matrix):\n                placed_circles += 1\n\n    return matrix\n\n\n# Example usage\nN = 199\nshape = (N, N)\nlength = 1.0\nndim = 2\n\n\nx = 10\nr = 20\nstructure = generate_matrix_with_circles(N, x, r)\n</code></pre> <pre><code>grid_size = (N,) * ndim\nelasticity_dof_shape = (ndim, ndim) + grid_size\n</code></pre>"},{"location":"examples/j2_plasticity/#assigning-material-parameters","title":"assigning material parameters","text":"<p>We assign material parameters to the two phases. The two phases within the RVE are denoted as - Soft = 0 - Hard = 1</p> <pre><code># material parameters + function to convert to grid of scalars\ndef param(X, soft, hard):\n    return hard * jnp.ones_like(X) * (X) + soft * jnp.ones_like(X) * (1 - X)\n</code></pre> <p>We consider a <code>linear isotropic hardening law</code> for both the phases</p> <pre><code># material parameters\nphase_constrast = 2\n\nK = param(structure, soft=0.833, hard=phase_constrast * 0.833)  # bulk      modulus\n\u03bc = param(structure, soft=0.386, hard=phase_constrast * 0.386)  # shear     modulus\nH = param(\n    structure, soft=2000.0e6 / 200.0e9, hard=phase_constrast * 2000.0e6 / 200.0e9\n)  # hardening modulus\nsigma_y = param(\n    structure, soft=600.0e6 / 200.0e9, hard=phase_constrast * 600.0e6 / 200.0e9\n)  # initial yield stress\n\nn = 1.0\n</code></pre>"},{"location":"examples/j2_plasticity/#plasticity-basics","title":"plasticity basics","text":"<p>Now we define the basics of plasticity implementation:</p> <ul> <li>yield surface</li> </ul> \\[ \\Phi(\\sigma_{ij}, \\varepsilon^p_{ij}) = \\underbrace{\\sqrt{\\dfrac{3}{2}\\sigma^{dev}_{ij}\\sigma^{dev}_{jk}}}_{\\sigma^{eq}} - (\\sigma_{0} + H\\varepsilon^{p}) \\] <ul> <li>return mappping algorithm</li> </ul> \\[ \\Delta \\varepsilon =  \\dfrac{\\langle \\Phi(\\sigma_{ij}, \\varepsilon_{p}) \\rangle_{+}}{3\\mu + H} \\] <ul> <li>tangent stiffness operator</li> </ul> \\[ \\mathbb{C} = \\dfrac{\\partial \\sigma^{t+1}}{\\partial \\varepsilon^{t+1}}  \\] <p>We also define certain Identity tensor for each grid point.</p> <ul> <li>\\(\\mathbf{I}\\) = 2 order Identity tensor with shape <code>(2, 2, N, N)</code> </li> <li>\\(\\mathbb{I4}\\) = 4 order Identity tensor with shape <code>(2, 2, 2, 2, N, N)</code></li> </ul> <pre><code>tensor = TensorOperator(dim=ndim)\nspace = SpectralSpace(size=N, dim=ndim, length=length)\n</code></pre> <pre><code># identity tensor (single tensor)\ni = jnp.eye(ndim)\n\n# identity tensors (grid)\nI = jnp.einsum(\n    \"ij,xy\",\n    i,\n    jnp.ones(\n        [\n            N,\n        ]\n        * ndim\n    ),\n)  # 2nd order Identity tensor\nI4 = jnp.einsum(\n    \"ijkl,xy-&gt;ijklxy\",\n    jnp.einsum(\"il,jk\", i, i),\n    jnp.ones(\n        [\n            N,\n        ]\n        * ndim\n    ),\n)  # 4th order Identity tensor\nI4rt = jnp.einsum(\n    \"ijkl,xy-&gt;ijklxy\",\n    jnp.einsum(\"ik,jl\", i, i),\n    jnp.ones(\n        [\n            N,\n        ]\n        * ndim\n    ),\n)\nI4s = (I4 + I4rt) / 2.0\n\nII = tensor.dyad(I, I)\nI4d = I4s - II / 3.0\n\nGhat = fourier_galerkin.compute_projection_operator(\n    space=space, diff_mode=DifferentialMode.rotated_difference\n)\n</code></pre> <pre><code>import equinox as eqx\n</code></pre> <pre><code>@jax.jit\ndef yield_function(ep: jnp.ndarray):\n    return sigma_y + H * ep**n\n\n\n@jax.jit\ndef compute_stress(eps: jnp.ndarray, args: tuple):\n    eps_t, epse_t, ep_t = args\n\n    # elastic stiffness tensor\n    C4e = K * II + 2.0 * \u03bc * I4d\n\n    # trial state\n    epse_s = epse_t + (eps - eps_t)\n    sig_s = tensor.ddot(C4e, epse_s)\n    sigm_s = tensor.ddot(sig_s, I) / 3.0\n    sigd_s = sig_s - sigm_s * I\n    sigeq_s = jnp.sqrt(3.0 / 2.0 * tensor.ddot(sigd_s, sigd_s))\n\n    # avoid zero division below (\"phi_s\" is corrected below)\n    Z = jnp.where(sigeq_s == 0, True, False)\n    sigeq_s = jnp.where(Z, 1, sigeq_s)\n\n    # evaluate yield surface, set to zero if elastic (or stress-free)\n    sigy = yield_function(ep_t)\n    phi_s = sigeq_s - sigy\n    phi_s = 1.0 / 2.0 * (phi_s + jnp.abs(phi_s))\n    phi_s = jnp.where(Z, 0.0, phi_s)\n    elastic_pt = jnp.where(phi_s &lt;= 0, True, False)\n\n    # plastic multiplier, based on non-linear hardening\n    # - initialize\n    dep = phi_s / (3 * \u03bc + H)\n\n    # return map algorithm\n    N = 3.0 / 2.0 * sigd_s / sigeq_s\n    ep = ep_t + dep\n    sig = sig_s - dep * N * 2.0 * \u03bc\n    epse = epse_s - dep * N\n\n    return sig, epse, ep\n\n\n@eqx.filter_jit\ndef compute_residual(sigma: jnp.ndarray) -&gt; jnp.ndarray:\n    return jnp.real(space.ifft(tensor.ddot(Ghat, space.fft(sigma)))).reshape(-1)\n\n\n@eqx.filter_jit\ndef compute_tangents(deps: jnp.ndarray, args: tuple):\n    deps = deps.reshape(ndim, ndim, N, N)\n    eps, eps_t, epse_t, ep_t = args\n    primal, tangents = jax.jvp(\n        partial(compute_stress, args=(eps_t, epse_t, ep_t)), (eps,), (deps,)\n    )\n    return compute_residual(tangents[0])\n\n\n# partial_compute_tangent = partial(compute_tangents, sigma=sigma)\n</code></pre> <pre><code>from spectralsolver.solvers.nonlinear import (\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\n</code></pre> <pre><code>@jax.jit\ndef newton_solver(state, n):\n    deps, b, eps, eps_t, epse_t, ep_t, En, sig = state\n\n    error = jnp.linalg.norm(deps) / En\n    jax.debug.print(\"residual={}\", jnp.linalg.norm(deps) / En)\n\n    def true_fun(state):\n        deps, b, eps, eps_t, epse_t, ep_t, En, sig = state\n\n        partial_compute_tangent = jax.jit(\n            partial(compute_tangents, args=(eps, eps_t, epse_t, ep_t))\n        )\n\n        deps, iiter = conjugate_gradient_while(\n            atol=1e-8,\n            A=partial_compute_tangent,\n            b=b,\n        )  # solve linear system using CG\n\n        deps = deps.reshape(eps.shape)\n        eps = jax.lax.add(eps, deps)  # update DOFs (array -&gt; tensor.grid)\n        sig, epse, ep = compute_stress(eps, (eps_t, epse_t, ep_t))\n        b = -compute_residual(sig)  # compute residual\n\n        jax.debug.print(\"CG iteration {}\", iiter)\n\n        return (deps, b, eps, eps_t, epse, ep, En, sig)\n\n    def false_fun(state):\n        return state\n\n    return jax.lax.cond(error &gt; 1e-8, true_fun, false_fun, state), n\n</code></pre> <pre><code># initialize: stress and strain tensor, and history\nsig = make_field(dim=ndim, N=N, rank=2)\neps = make_field(dim=ndim, N=N, rank=2)\neps_t = make_field(dim=ndim, N=N, rank=2)\nepse_t = make_field(dim=ndim, N=N, rank=2)\nep_t = make_field(dim=ndim, N=N, rank=2)\ndeps = make_field(dim=ndim, N=N, rank=2)\n\n# define incremental macroscopic strain\nninc = 100\nepsbar = 0.12\ndeps[0, 0] = jnp.sqrt(3.0) / 2.0 * epsbar / float(ninc)\ndeps[1, 1] = -jnp.sqrt(3.0) / 2.0 * epsbar / float(ninc)\n\nb = -compute_tangents(deps, (eps, eps_t, epse_t, ep_t))\neps = jax.lax.add(eps, deps)\nEn = jnp.linalg.norm(eps)\n</code></pre> <pre><code>state = (deps, b, eps, eps_t, epse_t, ep_t, En, sig)\nfinal_state, xs = jax.lax.scan(newton_solver, init=state, xs=jnp.arange(0, 10))\n</code></pre> <pre><code>residual=1.0\nCG iteration 18\nresidual=0.30347510072366196\nCG iteration 0\nresidual=0.0\nresidual=0.0\nresidual=0.0\nresidual=0.0\nresidual=0.0\nresidual=0.0\nresidual=0.0\nresidual=0.0\n</code></pre>"},{"location":"examples/linear_elasticity/","title":"Linear elasticity","text":"<p>This tutorial used Fourier-Galerkin method to solve a linear elasticity problem of a circular inclusion in a square matrix. The inclusion is a material with a different elastic properties than the matrix.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nfrom functools import partial\n\nimport equinox as eqx\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\n</code></pre> <p>In this example, we solve a linear elasticity problem of a circular inclusion in a square matrix. The inclusion is a material with a different elastic properties than the matrix. We use the Fourier-Galerkin method to solve the problem.</p> <p>We import the necessary modules and set up the environment. The module <code>xpektra</code> contains the operators and solvers for the Fourier-Galerkin method. We import the <code>SpectralSpace</code>, <code>SpectralOperator</code>, <code>make_field</code>, <code>RotatedDifference</code>, <code>FFTTransform</code>, <code>conjugate_gradient</code>, and <code>NewtonSolver</code> modules to create the operators and solvers.</p> <pre><code>from xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    NewtonSolver,\n    newton_krylov_solver,\n)\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.transform import FFTTransform\n</code></pre> <p>We define the grid size and the length of the RVE and construct the structure of the RVE.</p> <pre><code>N = 199\nndim = 2\nlength = 1\n\n\n# Create phase indicator (cylinder)\nx = np.linspace(-0.5, 0.5, N)\n\nif ndim == 3:\n    Y, X, Z = np.meshgrid(x, x, x, indexing=\"ij\")  # (N, N, N) grid\n    phase = jnp.where(X**2 + Z**2 &lt;= (0.2 / np.pi), 1.0, 0.0)  # 20% vol frac\nelse:\n    X, Y = np.meshgrid(x, x, indexing=\"ij\")  # (N, N) grid\n    phase = jnp.where(X**2 + Y**2 &lt;= (0.2 / np.pi), 1.0, 0.0)\n</code></pre>"},{"location":"examples/linear_elasticity/#defining-the-operators","title":"Defining the Operators","text":"<p>In order to define the Fourier-Galerkin operator, we first define the spectral space, the transform operators, and the spectral operators. We use the <code>SpectralSpace</code> class to define the spectral space, the <code>Fourier</code> class to define the FFT and IFFT operators, and the <code>RotatedDifference</code> class to define the spatial operators.</p> <p>Finally we define the Spectral Operators using the <code>SpectralOperator</code> class which takes the spectral space and the spatial operators as input.</p> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=phase.shape, transform=fft_transform\n)\nrotated_scheme = RotatedDifference(space=space)\n\nop = SpectralOperator(\n    scheme=rotated_scheme,\n    space=space,\n)\n</code></pre> <p>Next, we define the material parameters.</p> <pre><code># Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 10.0, 1000.0\nmu1, mu2 = 0.25, 2.5\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n</code></pre> <p>The linear elasticity strain energy is given as</p> \\[ W = \\frac{1}{2} \\int_{\\Omega}  (\\lambda \\text{tr}(\\epsilon)^2+ \\mu \\text{tr}(\\epsilon : \\epsilon ) ) d\\Omega \\] <p>We define a python function to compute the strain energy and then use the <code>jax.jacrev</code> function to compute the stress tensor.</p> <pre><code>dofs_shape = make_field(dim=ndim, shape=phase.shape, rank=2).shape\n\n\n@eqx.filter_jit\ndef strain_energy(eps_flat: Array) -&gt; Array:\n    eps = eps_flat.reshape(dofs_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambdas, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre> <p>In <code>xpektra</code>, we provide various projection operators. Here we use the <code>GalerkinProjection</code> operator to define the Fourier-Galerkin operator. A projecction operator projects a field onto a subspace. The Fourier-Galerkin operator projects the stress field onto the space of divergence-free fields in the Fourier space. To define a Projection operator, we need to provide the scheme to tell how to spatial differentiate. </p> <pre><code>Ghat = GalerkinProjection(scheme=rotated_scheme)\n</code></pre>"},{"location":"examples/linear_elasticity/#defining-the-residual-and-jacobian-functions","title":"Defining the Residual and Jacobian Functions","text":"<p>We now define the residual function and the Jacobian function for the Newton solver. The residual function computes the residual of the problem based on the given macro strain. It takes only the flattened vector of fluctuation strain and a macro strain. The Jacobian function represents the Jacobian-vector product.</p> <p>The total strain is given as</p> \\[\\mathbf{\\varepsilon} = \\tilde{\\mathbf{\\varepsilon}} + \\mathbf{\\varepsilon}_\\text{macro}^{i}  \\] <p>where \\(\\tilde{\\mathbf{\\varepsilon}}\\) is the fluctuation strain and \\(\\mathbf{\\varepsilon}_\\text{macro}^{i}\\) is the applied macro strain at iteration \\(i\\).</p> <p>The residual is given as</p> \\[R(\\tilde{\\mathbf{\\varepsilon}}, \\varepsilon_\\text{macro}) = \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\mathbf{\\sigma}(\\tilde{\\varepsilon} + \\varepsilon_\\text{macro}^{i})) \\right) \\] <p>where \\(\\mathbb{G}\\) is the Fourier-Galerkin operator defined earlier, \\(\\mathcal{F}\\) and \\(\\mathcal{F}^{-1}\\) are the FFT and IFFT operators respectively, and \\(\\mathbf{\\sigma}\\) is the stress tensor computed from the strain energy function defined earlier.</p> <p>We can define the residual at \\(\\tilde{\\varepsilon} + \\Delta \\tilde{\\varepsilon}\\) as</p> \\[R(\\tilde{\\mathbf{\\varepsilon}} + \\Delta \\tilde{\\mathbf{\\varepsilon}}, \\varepsilon_\\text{macro}) = \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\mathbf{\\sigma}(\\tilde{\\varepsilon} + \\Delta \\tilde{\\mathbf{\\varepsilon}} + \\varepsilon_\\text{macro}^{i})) \\right) \\] <p>USing the Taylor expansion, we can write</p> \\[R(\\tilde{\\mathbf{\\varepsilon}} + \\Delta \\tilde{\\mathbf{\\varepsilon}}, \\varepsilon_\\text{macro}) \\approx R(\\tilde{\\mathbf{\\varepsilon}}, \\varepsilon_\\text{macro}) + \\frac{\\partial R}{\\partial \\tilde{\\mathbf{\\varepsilon}}} \\Delta \\tilde{\\mathbf{\\varepsilon}} \\] <p>Below we define the residual function and the Jacobian function using the above equations.</p> <p>We use <code>op.forward</code> and <code>op.inverse</code> methods to apply the FFT and IFFT operators respectively.</p> <pre><code>@eqx.filter_jit\ndef residual_fn(eps_fluc_flat: Array, macro_strain: float) -&gt; Array:\n    \"\"\"\n    A function that computes the residual of the problem based on the given macro strain.\n    It takes only the flattened vector of fluctuation strain and a macro strain.\n\n    Args:\n        eps_fluc_flat: Flattened vector of fluctuation strain.\n        macro_strain: Macro strain.\n\n    Returns:\n        Residual field.\n    \"\"\"\n\n    eps_fluc = eps_fluc_flat.reshape(dofs_shape)\n    eps_macro = jnp.zeros(dofs_shape)\n    eps_macro = eps_macro.at[:, :, 0, 0].set(macro_strain)\n    eps_macro = eps_macro.at[:, :, 1, 1].set(macro_strain)\n    eps_total = eps_fluc + eps_macro\n    eps_flat = eps_total.reshape(-1)\n    sigma = compute_stress(eps_flat)\n    residual_field = op.inverse(Ghat.project(op.forward(sigma.reshape(dofs_shape))))\n    return jnp.real(residual_field).reshape(-1)\n\n\n@eqx.filter_jit\ndef jacobian_fn(deps_flat: Array) -&gt; Array:\n    \"\"\"\n    The Jacobian is a linear operator, so its represents the Jacobian-vector product.\n    For this linear elastic problem, we use the stress relation to compute the Jacobian.\n\n    Args:\n        deps_flat: The flattened displacement gradient field.\n\n    Returns:\n        The flattened Jacobian-vector product.\n    \"\"\"\n\n    deps_flat = deps_flat.reshape(-1)\n    dsigma = compute_stress(deps_flat)\n    jvp_field = op.inverse(Ghat.project(op.forward(dsigma.reshape(dofs_shape))))\n    return jnp.real(jvp_field).reshape(-1)\n</code></pre>"},{"location":"examples/linear_elasticity/#solving-the-problem-using-newton-krylov-solver","title":"Solving the Problem using Newton-Krylov Solver","text":"<p>We will use the Newton-Krylov solver to solve the problem. The Newton-Krylov solver requires the residual function and the Jacobian function as input.</p> <p>Finally, we define the macro strain and solve the problem using the Newton-Krylov solver. </p> <pre><code>applied_strains = jnp.diff(jnp.linspace(0, 1e-2, num=5))\n\n\nsolver = NewtonSolver(\n    tol=1e-8,\n    max_iter=20,\n    krylov_solver=conjugate_gradient,\n    krylov_tol=1e-8,\n    krylov_max_iter=20,\n)\n\neps_fluc_init = jnp.array(make_field(dim=2, shape=phase.shape, rank=2))\n\nfor inc, macro_strain in enumerate(applied_strains):\n    # partial residual function with current macro strain\n    residual_fn_partial = jax.jit(partial(residual_fn, macro_strain=macro_strain))\n\n    # initial residual at eps_fluc_init + macro_strain\n    b = -residual_fn_partial(eps_fluc_init.reshape(-1))\n\n    # solve for the fluctuation strain increment\n    deps_fluc = solver.solve(\n        x=eps_fluc_init.reshape(-1),\n        b=b,\n        f=residual_fn_partial,\n        jac=jacobian_fn,\n    )\n\n    # update fluctuation strain\n    eps_fluc = eps_fluc_init + deps_fluc.reshape(dofs_shape)\n\n    # update initial guess for next increment\n    eps_fluc_init = eps_fluc\n\n    # total strain\n    eps = eps_fluc + jnp.eye(2)[None, None, :, :] * macro_strain\n\n\neps = eps.reshape(dofs_shape)\nsig = compute_stress(eps.reshape(-1)).reshape(dofs_shape)\n</code></pre> <pre><code>Converged, Residual value : 8.73710891613419e-09\nConverged, Residual value : 8.73710891613419e-09\nConverged, Residual value : 8.684865135771586e-09\nConverged, Residual value : 6.343460638459792e-09\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3), layout=\"constrained\")\ncb1 = ax1.imshow(sig.at[:, :, 0, 0].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb1, cax=cax, label=r\"$\\sigma_{xx}$\", orientation=\"horizontal\", location=\"top\"\n)\n\ncb2 = ax2.imshow(eps.at[:, :, 0, 1].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb2, cax=cax, label=r\"$\\varepsilon_{xy}$\", orientation=\"horizontal\", location=\"top\"\n)\n\nax3.plot(eps.at[:, :, 0, 0].get()[:, int(N / 2)])\nax_twin = ax3.twinx()\nax_twin.plot(phase[int(N / 2), :], color=\"gray\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/linear_elasticity_rectangle/","title":"Linear elasticity rectangle","text":"<p>This tutorial used Fourier-Galerkin method to solve a linear elasticity problem of a circular inclusion in a square matrix. The inclusion is a material with a different elastic properties than the matrix.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\nimport equinox as eqx\n\nimport matplotlib.pyplot as plt\n</code></pre> <p>In this example, we solve a linear elasticity problem of a circular inclusion in a square matrix. The inclusion is a material with a different elastic properties than the matrix. We use the Fourier-Galerkin method to solve the problem.</p> <p>We import the necessary modules and set up the environment. The module <code>xpektra</code> contains the operators and solvers for the Fourier-Galerkin method. We import the <code>SpectralSpace</code>, <code>TensorOperator</code>, <code>make_field</code>, <code>RotatedDifference</code>, <code>Fourier</code>, <code>ForwardDifference</code>, <code>GalerkinProjection</code>, <code>conjugate_gradient_while</code>, and <code>newton_krylov_solver</code> modules to create the operators and solvers.</p> <pre><code>from xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\nfrom xpektra.transform import FFTTransform\nfrom xpektra.spectral_operator import SpectralOperator\n</code></pre> <p>To simplify the execution of the code, we define a <code>ElasticityOperator</code> class that contains the Fourier-Galerkin operator, the spatial operators, the tensor operators, and the FFT and IFFT operators. The <code>__init__</code> method initializes the operator and the <code>__call__</code> method computes the stresses in the real space given as </p> \\[ \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\mathbf{\\sigma}) \\right) = \\mathbf{0} \\] <p>We define the grid size and the length of the RVE and construct the structure of the RVE.</p> <pre><code>Nx = 151\nNy = 199\nndim = 2\nlx = 0.75\nly = 1.0\n\n\n# Create phase indicator (cylinder)\nx = np.linspace(-lx/2, lx/2, Nx)\ny = np.linspace(-ly/2, ly/2, Ny)\n\n\nif ndim == 3:\n    Y, X, Z = np.meshgrid(x, y, x, indexing=\"ij\")  # (N, N, N) grid\n    phase = jnp.where(X**2 + Z**2 &lt;= (0.2 / np.pi), 1.0, 0.0)  # 20% vol frac\nelse:\n    X, Y = np.meshgrid(x, y, indexing=\"ij\")  # (N, N) grid\n    phase = jnp.where(X**2 + Y**2 &lt;= (0.2 / np.pi), 1.0, 0.0)\n\n\nplt.figure(figsize=(5, 5))\nplt.imshow(phase.T, origin=\"lower\")\nplt.title(\"Phase indicator\")\nplt.colorbar(label=\"Phase\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/linear_elasticity_rectangle/#definin-the-tensor-operator-and-the-spectral-space","title":"Definin the tensor operator and the spectral space","text":"<pre><code># tensor = TensorOperator(dim=ndim)\n# space = SpectralSpace(size=N, dim=ndim, length=length)\n\nfft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(lx, ly), shape=phase.shape, transform=fft_transform\n)\nrotated_scheme = RotatedDifference(space=space)\n\nop = SpectralOperator(\n    scheme=rotated_scheme,\n    space=space,\n)\n</code></pre> <p>Next, we define the material parameters.</p> <pre><code># Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 10.0, 1e-3\nmu1, mu2 = 0.25, 2.5\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n</code></pre> <p>The linear elasticity strain energy is given as </p> \\[ W = \\frac{1}{2} \\int_{\\Omega}  (\\lambda \\text{tr}(\\epsilon)^2+ \\mu \\text{tr}(\\epsilon : \\epsilon ) ) d\\Omega \\] <p>We define a python function to compute the strain energy and then use the <code>jax.jacrev</code> function to compute the stress tensor.</p> <pre><code>dofs_shape = make_field(dim=ndim, shape=phase.shape, rank=2).shape\n\n\n@eqx.filter_jit\ndef strain_energy(eps_flat: Array) -&gt; Array:\n    eps = eps_flat.reshape(dofs_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambdas, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre> <pre><code>Ghat = GalerkinProjection(scheme=rotated_scheme)\n</code></pre> <pre><code>class Residual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    Ghat: Array\n    dofs_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, eps_flat: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        eps_flat = eps_flat.reshape(-1)\n        sigma = compute_stress(eps_flat)\n        residual_field = op.inverse(\n            Ghat.project(op.forward(sigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(residual_field).reshape(-1)\n\n\nclass Jacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    Ghat: Array\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, deps_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n\n        deps_flat = deps_flat.reshape(-1)\n        dsigma = compute_stress(deps_flat)\n        jvp_field = op.inverse(\n            Ghat.project(op.forward(dsigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(jvp_field).reshape(-1)\n</code></pre> <pre><code>applied_strains = jnp.diff(jnp.linspace(0, 1e-2, num=5))\n\ndeps = make_field(dim=2, shape=phase.shape, rank=2)\neps = make_field(dim=2, shape=phase.shape, rank=2)\n\nresidual_fn = Residual(Ghat=Ghat, dofs_shape=eps.shape)\njacobian_fn = Jacobian(Ghat=Ghat, dofs_shape=eps.shape)\n\n\nfor inc, deps_avg in enumerate(applied_strains):\n    # solving for elasticity\n    deps[:, :, 1, 1] = deps_avg\n\n    b = -residual_fn(deps.reshape(-1))  # initial residual\n    eps = eps + deps\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_fn,\n        jacobian=jacobian_fn,\n        tol=1e-8,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n    eps = final_state[2]\n\neps = final_state[2].reshape(dofs_shape)\nsig = compute_stress(final_state[2]).reshape(dofs_shape)\n</code></pre> <pre><code>CG error = 2.19220556404430\nCG error = 0.00000000769428\nCG error = 0.00000000000000\nConverged, Residual value : 4.713518095401891e-09\nCG error = 2.19220556404430\nCG error = 0.00000000769428\nCG error = 0.00000000000000\nConverged, Residual value : 4.7137296986377675e-09\nCG error = 2.19220556404430\nCG error = 0.00000000769428\nCG error = 0.00000000000000\nConverged, Residual value : 4.713729852672502e-09\nCG error = 2.19220556404430\nCG error = 0.00000000769428\nCG error = 0.00000000000000\nConverged, Residual value : 4.7137298527402765e-09\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3), layout=\"constrained\")\ncb1 = ax1.imshow(sig.at[:, :, 0, 0].get().T, cmap=\"managua_r\", origin='lower')\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(cb1, cax=cax, label=r\"$\\sigma_{yy}$\", orientation=\"horizontal\", location=\"top\")\n\ncb2 = ax2.imshow(eps.at[:, :, 1, 1].get().T, cmap=\"managua_r\", origin='lower')\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(cb2, cax=cax, label=r\"$\\varepsilon_{xy}$\", orientation=\"horizontal\", location=\"top\")\n\nax3.plot(sig.at[:, :, 0, 0].get()[int(Ny / 2), :])\nax_twin = ax3.twinx()\nax_twin.plot(phase[int(Ny / 2), :], color=\"gray\")\nplt.show()\n</code></pre> <p></p> <pre><code>deps\n</code></pre> <pre><code>array([[[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]],\n\n\n       [[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]],\n\n\n       [[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]],\n\n\n       ...,\n\n\n       [[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]],\n\n\n       [[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]],\n\n\n       [[[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        ...,\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]],\n\n        [[0.    , 0.    ],\n         [0.    , 0.0025]]]], shape=(151, 199, 2, 2))\n</code></pre> <pre><code>jnp.mean(eps.at[:, :, 1, 1].get())\n</code></pre> <pre><code>Array(0.01, dtype=float64)\n</code></pre> <pre><code>jnp.mean(sig.at[:, :, 1, 1].get())\n</code></pre> <pre><code>Array(0.06316598, dtype=float64)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/moulinec_suquet/","title":"Fixed-point iteration","text":"<p>In this tutorial, we will solve the homogenization problem using Moulinec-Suquet's fixed-point iteration scheme.</p> <pre><code>import jax\n\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\n\nimport time\nfrom functools import partial\n\nimport equinox as eqx\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom jax import Array\n\nfrom xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.projection_operator import MoulinecSuquetProjection\nfrom xpektra.scheme import FourierScheme\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.transform import FFTTransform\n</code></pre> <p>Let us start by defining the RVE geometry. We will consider a 2D square RVE with a circular inclusion.</p> <pre><code>N = 251\nndim = 2\nlength = 1\n</code></pre> <pre><code># Create phase indicator (cylinder)\nx = np.linspace(-0.5, 0.5, N)\n\nif ndim == 3:\n    Y, X, Z = np.meshgrid(x, x, x, indexing=\"ij\")  # (N, N, N) grid\n    phase = jnp.where(X**2 + Z**2 &lt;= (0.2 / np.pi), 1.0, 0.0)  # 20% vol frac\nelse:\n    X, Y = np.meshgrid(x, x, indexing=\"ij\")  # (N, N) grid\n    phase = jnp.where(X**2 + Y**2 &lt;= (0.2 / np.pi), 1.0, 0.0)\n</code></pre>"},{"location":"examples/moulinec_suquet/#define-the-material-parameters","title":"Define the material parameters","text":"<p>We consider a two-phase material with the following material parameters:</p> <p>The first Lam\u00e9 parameter is \\(\\lambda_1 = 10.0\\) and the second is \\(\\lambda_2 = 100.0\\) and shear moduli are \\(\\mu_1 = 0.25, \\mu_2 = 2.5\\)</p> <pre><code># Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 10.0, 100.0\nmu1, mu2 = 0.25, 2.5\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n</code></pre> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(lengths=(length, length), shape=(N, N), transform=fft_transform)\n\ndiff_scheme = FourierScheme(space=space)\n\nop = SpectralOperator(\n    scheme=diff_scheme,\n    space=space,\n)\n</code></pre> <pre><code>i = jnp.eye(ndim)\nI = make_field(dim=ndim, shape=(N, N), rank=2) + i  # Add i to broadcast\n\nI4 = jnp.einsum(\"il,jk-&gt;ijkl\", i, i)\nI4rt = jnp.einsum(\"ik,jl-&gt;ijkl\", i, i)\nI4s = (I4 + I4rt) / 2.0\nII = jnp.einsum(\"...ij,...kl-&gt;...ijkl\", I, I)\n\n# Broadcast scalars to the 4th-order tensor shape\nC4 = (\n    lambdas[..., None, None, None, None] * II\n    + (2.0 * mu[..., None, None, None, None]) * I4s\n)\n\n# Use average properties for the reference material\nlambda0 = (lambda1 + lambda2) / 2.0\nmu0 = (mu1 + mu2) / 2.0\n\n# Build the constant C0 reference tensor [shape (3,3,3,3)]\nC0 = lambda0 * II + 2.0 * mu0 * I4s\n</code></pre> <pre><code>Ghat = MoulinecSuquetProjection(\n    space=space, lambda0=lambda0, mu0=mu0\n).compute_operator()\n</code></pre> <pre><code>@partial(jax.jit, static_argnames=[\"max_iter\", \"tol\"])\ndef fixed_point_iteration(\n    E_macro: Array, eps_guess: Array, max_iter: int, tol: float\n) -&gt; Array:\n    \"\"\"Solves the Lippmann-Schwinger equation via fixed-point iteration.\"\"\"\n\n    eps = eps_guess\n\n    def cond_fun(state):\n        eps_k, eps_prev, k = state\n        err = jnp.linalg.norm(eps_k - eps_prev) / jnp.linalg.norm(E_macro)\n        jax.debug.print(\"Error: {err}\", err=err)\n        return jnp.logical_and(err &gt; tol, k &lt; max_iter)\n\n    def body_fun(state):\n        eps_k, _, k = state\n\n        # Calculate stress and polarization\n        sigma = op.ddot(C4, eps_k)\n        sigma0 = op.ddot(C0, eps_k)\n        tau = sigma - sigma0  # Polarization field tau = \u03c3 - C0:\u03b5\n\n        # Apply Green's operator: \u03b5_fluc = G^0 * tau\n        tau_hat = op.forward(tau)\n        eps_fluc_hat = op.ddot(Ghat, tau_hat)  # project(Ghat, tau_hat)\n        eps_fluc = jnp.real(op.inverse(eps_fluc_hat))\n\n        # Update total strain: \u03b5_new = E_macro - \u03b5_fluc\n        eps_new = E_macro - eps_fluc\n\n        return (eps_new, eps_k, k + 1)\n\n    (eps_final, _, num_iters) = jax.lax.while_loop(\n        cond_fun, body_fun, (eps, jnp.zeros_like(eps), 0)\n    )\n\n    # jax.debug.print(\"Converged in {i} iterations\", i=num_iters)\n    return eps_final\n</code></pre> <pre><code># --- solve for load cases &amp; homogenize ---\nif ndim == 3:\n    E_list = [\n        jnp.array(\n            [[1, 0, 0], [0, 0, 0], [0, 0, 0]],\n        ),  # E_xx\n        jnp.array(\n            [[0, 0, 0], [0, 1, 0], [0, 0, 0]],\n        ),  # E_yy\n        jnp.array(\n            [[0, 0, 0], [0, 0, 0], [0, 0, 1]],\n        ),  # E_zz\n        jnp.array(\n            [[0, 1, 0], [1, 0, 0], [0, 0, 0]],\n        ),  # 2E_xy\n        jnp.array(\n            [[0, 0, 0], [0, 0, 1], [0, 1, 0]],\n        ),  # 2E_yz\n        jnp.array(\n            [[0, 0, 1], [1, 0, 0], [0, 0, 0]],\n        ),  # 2E_xz\n    ]\n\n    homogenized_stiffness = jnp.zeros((6, 6))\n    voigt_indices = [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (0, 2)]\n\nelse:\n    E_list = [\n        jnp.array(\n            [[1, 0], [0, 0]],\n        ),  # E_xx\n        jnp.array(\n            [[0, 0], [0, 1]],\n        ),  # E_yy\n        jnp.array(\n            [[0, 1], [1, 0]],\n        ),  # 2E_xy\n    ]\n\n    homogenized_stiffness = jnp.zeros((2, 2))\n    voigt_indices = [(0, 0), (1, 1), (0, 1)]\n\n\nprint(\"Starting homogenization...\")\nfor i, E_voigt in enumerate(E_list):\n    # Create the full E_macro field (broadcasts E_voigt)\n    E_macro = make_field(dim=ndim, shape=(N, N), rank=2) + E_voigt\n\n    # Solve the RVE problem\n    eps_final = fixed_point_iteration(\n        E_macro, eps_guess=E_macro, max_iter=200, tol=1e-8\n    )\n\n    # Compute the final stress field\n    sig_final = op.ddot(C4, eps_final)\n\n    # Homogenize (average over the volume)\n    if ndim == 3:\n        avg_stress = jnp.mean(sig_final, axis=(0, 1, 2))\n    else:\n        avg_stress = jnp.mean(sig_final, axis=(0, 1))\n\n    # Store in Voigt notation\n    for j, (row, col) in enumerate(voigt_indices):\n        homogenized_stiffness = homogenized_stiffness.at[j, i].set(avg_stress[row, col])\n\nprint(\"Homogenized Stiffness (Voigt): \\n\", homogenized_stiffness)\n\n\nplt.imshow(sig_final.at[:, :, 0, 0].get(), cmap=\"managua\")\nplt.colorbar()\nplt.show()\n</code></pre> <pre><code>Starting homogenization...\nError: 1.0\nError: 0.6935031302765594\nError: 0.3103770106405334\nError: 0.14122247521171297\nError: 0.06533922903456445\nError: 0.030786000216867407\nError: 0.015066600272192029\nError: 0.00792539496671916\nError: 0.004684895298773023\nError: 0.0031299500540455244\nError: 0.002277436688405015\nError: 0.0017315062118714007\nError: 0.0013418840557507692\nError: 0.0010498324247963464\nError: 0.0008248874032332835\nError: 0.0006504702360824441\nError: 0.0005139244311458543\nError: 0.000407041758329968\nError: 0.0003228308437711801\nError: 0.00025656451397461334\nError: 0.00020412611882427887\nError: 0.00016269392059947013\nError: 0.0001297906933737519\nError: 0.00010370503248918223\nError: 8.292625774009405e-05\nError: 6.640458782032647e-05\nError: 5.320931960125312e-05\nError: 4.2690544794933e-05\nError: 3.427006097834183e-05\nError: 2.754233639942546e-05\nError: 2.2145605171604346e-05\nError: 1.7825076002272905e-05\nError: 1.435300320243211e-05\nError: 1.1568326017600169e-05\nError: 9.326888270948043e-06\nError: 7.526324186483838e-06\nError: 6.07494446174148e-06\nError: 4.907371244007024e-06\nError: 3.965033194031198e-06\nError: 3.2059935944095537e-06\nError: 2.592691372563256e-06\nError: 2.098121518259586e-06\nError: 1.698112547180605e-06\nError: 1.3752143853155828e-06\nError: 1.1138234233210102e-06\nError: 9.02629014712068e-07\nError: 7.315301925525317e-07\nError: 5.931756355869575e-07\nError: 4.810100663755175e-07\nError: 3.9024390703505294e-07\nError: 3.1661335837505987e-07\nError: 2.569911642211907e-07\nError: 2.0859838368409955e-07\nError: 1.6938924148046756e-07\nError: 1.3754927064010818e-07\nError: 1.1173790962527595e-07\nError: 9.076849870248438e-08\nError: 7.376127212898336e-08\nError: 5.993901730424165e-08\nError: 4.87236036965951e-08\nError: 3.9605316900990294e-08\nError: 3.220379315118077e-08\nError: 2.6184351116830385e-08\nError: 2.1296477664837015e-08\nError: 1.732018237424785e-08\nError: 1.4090318361334832e-08\nError: 1.1462141904618898e-08\nError: 9.32669085446741e-09\nError: 1.0\nError: 0.6935031302765594\nError: 0.31037701064053336\nError: 0.14122247521171286\nError: 0.0653392290345642\nError: 0.030786000216867414\nError: 0.01506660027219208\nError: 0.007925394966719143\nError: 0.004684895298772996\nError: 0.00312995005404544\nError: 0.0022774366884048946\nError: 0.0017315062118712803\nError: 0.0013418840557506684\nError: 0.0010498324247962625\nError: 0.0008248874032331897\nError: 0.000650470236082357\nError: 0.0005139244311457765\nError: 0.00040704175832992654\nError: 0.00032283084377118126\nError: 0.0002565645139746209\nError: 0.00020412611882427933\nError: 0.00016269392059946823\nError: 0.00012979069337374925\nError: 0.00010370503248916076\nError: 8.292625774006554e-05\nError: 6.640458782027611e-05\nError: 5.32093196011756e-05\nError: 4.269054479485732e-05\nError: 3.427006097827245e-05\nError: 2.7542336399358607e-05\nError: 2.214560517156083e-05\nError: 1.7825076002236923e-05\nError: 1.4353003202394185e-05\nError: 1.1568326017584977e-05\nError: 9.32688827093571e-06\nError: 7.526324186453697e-06\nError: 6.0749444617153865e-06\nError: 4.907371243989694e-06\nError: 3.965033194018279e-06\nError: 3.205993594380372e-06\nError: 2.5926913725276158e-06\nError: 2.0981215182092944e-06\nError: 1.698112547146453e-06\nError: 1.375214385298593e-06\nError: 1.1138234233181492e-06\nError: 9.026290147219088e-07\nError: 7.315301925301596e-07\nError: 5.931756355526913e-07\nError: 4.810100663784345e-07\nError: 3.902439070766536e-07\nError: 3.1661335841661996e-07\nError: 2.569911642407797e-07\nError: 2.0859838370121595e-07\nError: 1.6938924148361291e-07\nError: 1.3754927063089193e-07\nError: 1.1173790961783615e-07\nError: 9.07684986978607e-08\nError: 7.376127212069506e-08\nError: 5.993901729644183e-08\nError: 4.8723603698134755e-08\nError: 3.960531688153151e-08\nError: 3.2203793111844174e-08\nError: 2.6184351079556184e-08\nError: 2.129647767407521e-08\nError: 1.7320182430818884e-08\nError: 1.4090318462841898e-08\nError: 1.1462142037886911e-08\nError: 9.326690977475919e-09\nError: 1.0\nError: 0.5266718859695122\nError: 0.0349673206121437\nError: 0.010961719238350667\nError: 0.006471143050372437\nError: 0.004230327905581393\nError: 0.002941118560935299\nError: 0.002131643836046506\nError: 0.0015928545782293196\nError: 0.0012132402466736476\nError: 0.0009377709852979468\nError: 0.0007312724469387376\nError: 0.0005745015733640879\nError: 0.00045334515374911166\nError: 0.00035922928188704113\nError: 0.00028536294469459647\nError: 0.0002272687837220055\nError: 0.00018128426421254915\nError: 0.00014485497155787135\nError: 0.00011587019947719534\nError: 9.280139200293281e-05\nError: 7.438416369970654e-05\nError: 5.967905250863202e-05\nError: 4.7910600741528165e-05\nError: 3.849211623653773e-05\nError: 3.09407480463925e-05\nError: 2.4886349460043065e-05\nError: 2.0025149881239583e-05\nError: 1.612199185386992e-05\nError: 1.2984346310743811e-05\nError: 1.0462063451571944e-05\nError: 8.432435218212186e-06\nError: 6.799223681439116e-06\nError: 5.483877367404888e-06\nError: 4.424526487758379e-06\nError: 3.5707072929509048e-06\nError: 2.882546174792068e-06\nError: 2.327527832380616e-06\nError: 1.879901039326172e-06\nError: 1.5186627437189383e-06\nError: 1.2271523750398519e-06\nError: 9.917739791870485e-07\nError: 8.017315235547645e-07\nError: 6.48207496397955e-07\nError: 5.241963284999641e-07\nError: 4.239701922625426e-07\nError: 3.429774858518625e-07\nError: 2.774920913207678e-07\nError: 2.2455344897352704e-07\nError: 1.8173453259045253e-07\nError: 1.4710769627481844e-07\nError: 1.190902980865383e-07\nError: 9.642605911865163e-08\nError: 7.808191082908235e-08\nError: 6.323841367319836e-08\nError: 5.122062139665694e-08\nError: 4.1493611631776986e-08\nError: 3.3616053418117805e-08\nError: 2.7238499060655853e-08\nError: 2.207215890110293e-08\nError: 1.788859466936171e-08\nError: 1.449870600040102e-08\nError: 1.1753065157944821e-08\nError: 9.52777196957291e-09\nHomogenized Stiffness (Voigt): \n [[12.9037581  12.15660601]\n [12.15660601 12.9037581 ]]\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/moulinec_suquet_newton_krylov/","title":"Moulinec-Suquet as Newton-Krylov solver","text":"<p>In this tutorial, we will solve a linear elasticity problem using Moulinec-Suquet's Green's operator but recasted the Lippmann-Schwinger equation as a Newton-Krylov solver.</p> <pre><code>import jax\n\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\n\nimport jax.numpy as jnp\nfrom jax import Array\n\nimport numpy as np\nimport equinox as eqx\n\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code>from xpektra import (\n    SpectralSpace,\n    make_field,\n)\nfrom xpektra.transform import FFTTransform\nfrom xpektra.scheme import FourierScheme\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.projection_operator import MoulinecSuquetProjection\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\n</code></pre> <p>Let us start by defining the RVE geometry. We will consider a 2D square RVE with a circular inclusion.</p> <pre><code>N = 99\nndim = 2\nlength = 1\n\n\n# Create phase indicator (cylinder)\nx = np.linspace(-0.5, 0.5, N)\n\nif ndim == 3:\n    Y, X, Z = np.meshgrid(x, x, x, indexing=\"ij\")  # (N, N, N) grid\n    phase = jnp.where(X**2 + Z**2 &lt;= (0.2 / np.pi), 1.0, 0.0)  # 20% vol frac\nelse:\n    X, Y = np.meshgrid(x, x, indexing=\"ij\")  # (N, N) grid\n    phase = jnp.where(X**2 + Y**2 &lt;= (0.2 / np.pi), 1.0, 0.0)\n\n\nplt.figure(figsize=(3, 3))\ncb = plt.imshow(phase, origin=\"lower\")\nplt.colorbar(cb, label=\"Phase indicator\")\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$y$\")\nplt.show()\n</code></pre> <p></p> <p>Based on the phase indicator, we can now define the material parameters. We will consider a linear elastic material with different properties in the inclusion and the matrix.</p> <pre><code># Material parameters [grids of scalars, shape (N,N,N)]\nlambda1, lambda2 = 10.0, 1000.0\nmu1, mu2 = 0.25, 2.5\nlambdas = lambda1 * (1.0 - phase) + lambda2 * phase\nmu = mu1 * (1.0 - phase) + mu2 * phase\n</code></pre>"},{"location":"examples/moulinec_suquet_newton_krylov/#defining-tensoroperator-and-spectralspace","title":"Defining TensorOperator and SpectralSpace","text":"<pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=phase.shape, transform=fft_transform\n)\nfourier_scheme = FourierScheme(space=space)\n\nop = SpectralOperator(\n    scheme=fourier_scheme,\n    space=space,\n)\n</code></pre>"},{"location":"examples/moulinec_suquet_newton_krylov/#defining-the-constitutive-law","title":"Defining the constitutive law","text":"<pre><code>@eqx.filter_jit\ndef _strain_energy(eps: Array, lambdas: Array, mu: Array) -&gt; Array:\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambdas, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n</code></pre>"},{"location":"examples/moulinec_suquet_newton_krylov/#defining-the-reference-material-for-moulinec-suquet-projection","title":"Defining the reference material for Moulinec-Suquet projection","text":"<p>To define the reference material, we will use the average properties of the material. We make use of <code>jax.jacrev</code> to compute the stress tensor as a function of the strain tensor. This way we do not need to store the reference material tensor in memory.</p> <pre><code># Use average properties for the reference material\nlambda0 = (lambda1 + lambda2) / 2.0\nmu0 = (mu1 + mu2) / 2.0\n\nmaterial_energy = eqx.Partial(_strain_energy, lambdas=lambdas, mu=mu)\nreference_energy = eqx.Partial(_strain_energy, lambdas=lambda0, mu=mu0)\n\ncompute_stress = jax.jacrev(material_energy)\ncompute_reference_stress = jax.jacrev(reference_energy)\n</code></pre> <p>To check the correctness of our reference material, we can compare the stress computed using the reference material tensor with the stress computed using the average properties.</p> <pre><code>i = jnp.eye(ndim)\nI = make_field(dim=ndim, shape=(N, N), rank=2) + i  # Add i to broadcast\n\nI4 = jnp.einsum(\"il,jk-&gt;ijkl\", i, i)\nI4rt = jnp.einsum(\"ik,jl-&gt;ijkl\", i, i)\nI4s = (I4 + I4rt) / 2.0\nII = jnp.einsum(\"...ij,...kl-&gt;...ijkl\", I, I)\n\n# Build the constant C0 reference tensor [shape (3,3,3,3)]\nC0 = lambda0 * II + 2.0 * mu0 * I4s\n\nassert np.allclose(op.ddot(C0, I), compute_reference_stress(I)), (\n    \"Reference stress computation is incorrect\"\n)\n</code></pre> <p>We can now define the Moulinec-Suquet projection operator.</p> <pre><code>Ghat = MoulinecSuquetProjection(\n    space=space, lambda0=lambda0, mu0=mu0\n).compute_operator()\n</code></pre>"},{"location":"examples/moulinec_suquet_newton_krylov/#defining-the-residual-and-jacobian","title":"Defining the residual and Jacobian","text":"<pre><code>class Residual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    Ghat: Array\n    dofs_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, eps_flat: Array, eps_macro: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        eps = eps_flat.reshape(self.dofs_shape)\n        sigma = compute_stress(eps)\n        sigma0 = compute_reference_stress(eps)\n        tau = sigma - sigma0\n        eps_fluc = op.inverse(op.ddot(self.Ghat, op.forward(tau)))\n\n        residual_field = eps - eps_macro + jnp.real(eps_fluc)\n\n        return residual_field.reshape(-1)\n\n\nclass Jacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    Ghat: Array\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, deps_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n\n        deps = deps_flat.reshape(self.dofs_shape)\n\n        dsigma = compute_stress(deps)\n        dsigma0 = compute_reference_stress(deps)\n        dtau = dsigma - dsigma0\n        jvp_field = op.inverse(op.ddot(self.Ghat, op.forward(dtau)))\n        jvp_field = jnp.real(jvp_field) + deps\n        return jvp_field.reshape(-1)\n</code></pre> <pre><code>applied_strains = jnp.linspace(0, 1e-2, num=5)\n\neps = make_field(dim=2, shape=(N, N), rank=2)\ndeps = make_field(dim=2, shape=(N, N), rank=2)\neps_macro = make_field(dim=2, shape=(N, N), rank=2)\n\nresidual_fn = Residual(Ghat=Ghat, dofs_shape=eps.shape)\njacobian_fn = Jacobian(Ghat=Ghat, dofs_shape=eps.shape)\n\n\nfor inc, eps_avg in enumerate(applied_strains):\n    # solving for elasticity\n    eps_macro[:, :, 0, 0] = eps_avg\n    eps_macro[:, :, 1, 1] = eps_avg\n\n    residual_partial = eqx.Partial(residual_fn, eps_macro=eps_macro)\n\n    b = -residual_partial(eps)\n    # eps = eps + deps\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_partial,\n        jacobian=jacobian_fn,\n        tol=1e-8,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-8,\n        krylov_max_iter=20,\n    )\n    eps = final_state[2]\n\nsig = compute_stress(final_state[2])\n</code></pre> <pre><code>Converged, Residual value : 0.0\nCG error = 0.12251249999999\nCG error = 0.74556223960762\nCG error = 3.62552279148263\nCG error = 0.00000000000267\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nConverged, Residual value : 7.317105475171182e-09\nCG error = 0.12251249996303\nCG error = 0.74556223900860\nCG error = 3.62552279079509\nCG error = 0.00000000000267\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nConverged, Residual value : 7.317901040259387e-09\nCG error = 0.12251249996308\nCG error = 0.74556223900974\nCG error = 3.62552279079039\nCG error = 0.00000000000267\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nConverged, Residual value : 7.3178971612309414e-09\nCG error = 0.12251249996308\nCG error = 0.74556223900970\nCG error = 3.62552279079037\nCG error = 0.00000000000267\nCG error = 0.00000000000001\nCG error = 0.00000000000000\nConverged, Residual value : 7.317911913185927e-09\n</code></pre> <pre><code>from mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3), layout=\"constrained\")\ncb1 = ax1.imshow(sig.at[:, :, 0, 0].get(), cmap=\"managua_r\")\n\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb1, cax=cax, label=r\"$\\sigma_{xx}$\", orientation=\"horizontal\", location=\"top\"\n)\n\ncb2 = ax2.imshow(eps.at[:, :, 0, 1].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb2, cax=cax, label=r\"$\\varepsilon_{xy}$\", orientation=\"horizontal\", location=\"top\"\n)\n\nax3.plot(sig.at[:, :, 0, 0].get()[:, int(N / 2)])\nax_twin = ax3.twinx()\nax_twin.plot(phase[int(N / 2), :], color=\"gray\")\nplt.show()\n</code></pre>"},{"location":"examples/multiphase_material/","title":"3D Multi-phase Material","text":"<pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\n\nimport jax.numpy as jnp\nfrom jax import Array\nimport numpy as np\n</code></pre> <p>In this example, we solve a linear elasticity problem of a  multiphase material in 3D.</p> <pre><code>from xpektra import (\n    SpectralSpace,\n    TensorOperator,\n    make_field,\n)\nfrom xpektra.scheme import RotatedDifference, Fourier\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient_while,\n    newton_krylov_solver,\n)\n\nimport equinox as eqx\n</code></pre> <pre><code>from scipy.spatial.distance import cdist\n\n\ndef generate_multiphase_material_3d(\n    size, num_phases=5, num_seeds=None, random_state=None\n):\n    \"\"\"\n    Generate a 3D multiphase material using Voronoi tessellation.\n\n    Parameters:\n    -----------\n    size : int or tuple of 3 ints\n        Size of the 3D array. If int, creates a cubic array of size (size, size, size).\n        If tuple, specifies (nx, ny, nz) dimensions.\n    num_phases : int, default=5\n        Number of different phases (materials) in the microstructure.\n    num_seeds : int, optional\n        Number of Voronoi seed points. If None, defaults to num_phases * 3.\n    random_state : int, optional\n        Random seed for reproducibility.\n\n    Returns:\n    --------\n    material : numpy.ndarray\n        3D array with values from 0 to 1, where each phase is represented by\n        values in the range [i/num_phases, (i+1)/num_phases) for phase i.\n    seed_points : numpy.ndarray\n        Array of seed points used for Voronoi tessellation.\n    \"\"\"\n\n    if random_state is not None:\n        np.random.seed(random_state)\n\n    # Handle size parameter\n    if isinstance(size, int):\n        nx, ny, nz = size, size, size\n    else:\n        nx, ny, nz = size\n\n    # Default number of seeds\n    if num_seeds is None:\n        num_seeds = num_phases * 3\n\n    # Generate random seed points in 3D space\n    seed_points = np.random.rand(num_seeds, 3)\n    seed_points[:, 0] *= nx\n    seed_points[:, 1] *= ny\n    seed_points[:, 2] *= nz\n\n    # Assign each seed to a phase\n    seed_phases = np.random.randint(0, num_phases, num_seeds)\n\n    # Create coordinate grids\n    x, y, z = np.meshgrid(np.arange(nx), np.arange(ny), np.arange(nz), indexing=\"ij\")\n    grid_points = np.column_stack([x.ravel(), y.ravel(), z.ravel()])\n\n    # Calculate distances from each grid point to all seed points\n    distances = cdist(grid_points, seed_points)\n\n    # Find closest seed for each grid point\n    closest_seeds = np.argmin(distances, axis=1)\n\n    # Assign phases based on closest seed\n    phase_array = seed_phases[closest_seeds].reshape(nx, ny, nz)\n\n    # Convert to values between 0 and 1\n    material = phase_array.astype(float) / num_phases + np.random.rand(nx, ny, nz) / (\n        num_phases * 10\n    )\n    material = np.clip(material, 0, 1)\n\n    return material, seed_points\n</code></pre> <p>We use the <code>generate_multiphase_material_3d</code> function to generate a 3D multiphase material. The function returns the material and the seed points.</p> <pre><code>N = 31\nndim = 3\nlength = 1\n\nstructure, seeds = generate_multiphase_material_3d(\n    size=N, num_phases=5, num_seeds=15, random_state=42\n)\n</code></pre> <p>To simplify the execution of the code, we define a <code>ElasticityOperator</code> class that contains the Fourier-Galerkin operator, the spatial operators, the tensor operators, and the FFT and IFFT operators. The <code>__init__</code> method initializes the operator and the <code>__call__</code> method computes the stresses in the real space given as </p> <p>$$ \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\sigma) \\right)</p> <p>$$</p> <p>We define the grid size and the length of the RVE and construct the structure of the RVE.</p> <pre><code>tensor = TensorOperator(dim=ndim)\nspace = SpectralSpace(size=N, dim=ndim, length=length)\n</code></pre> <p>Next, we define the material parameters.</p> <pre><code>\u03bb0 = structure.copy()\n\u03bc0 = structure.copy()\n</code></pre> <pre><code>Ghat = GalerkinProjection(scheme=RotatedDifference(space=space)).compute_operator()\n\n\ndofs_shape = make_field(dim=ndim, N=N, rank=2).shape\n</code></pre> <p>The linear elasticity strain energy is given as  $$ W = \\frac{1}{2} \\int_{\\Omega}  (\\lambda \\text{tr}(\\epsilon)^2+ \\mu \\text{tr}(\\epsilon : \\epsilon ) ) d\\Omega $$</p> <p>We define a python function to compute the strain energy and then use the <code>jax.jacrev</code> function to compute the stress tensor.</p> <pre><code>@eqx.filter_jit\ndef strain_energy(eps_flat: Array) -&gt; float:\n    eps = eps_flat.reshape(dofs_shape)\n    eps_sym = 0.5 * (eps + tensor.trans(eps))\n    energy = 0.5 * jnp.multiply(\u03bb0, tensor.trace(eps_sym) ** 2) + jnp.multiply(\n        \u03bc0, tensor.trace(tensor.dot(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre> <pre><code>class Residual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    Ghat: Array\n    space: SpectralSpace = eqx.field(static=True)\n    tensor_op: TensorOperator = eqx.field(static=True)\n    dofs_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, eps_flat: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        # eps = eps_flat.reshape(self.dofs_shape)\n        sigma = compute_stress(eps_flat)  # Assumes compute_stress is defined elsewhere\n\n        residual_field = self.space.ifft(\n            self.tensor_op.ddot(\n                self.Ghat, self.space.fft(sigma.reshape(self.dofs_shape))\n            )\n        )\n        return jnp.real(residual_field).reshape(-1)\n\n\nclass Jacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    Ghat: Array\n    space: SpectralSpace = eqx.field(static=True)\n    tensor_op: TensorOperator = eqx.field(static=True)\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, deps_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n        # deps = deps_flat.reshape(self.dofs_shape)\n        # Assuming linear elasticity, the tangent is the same as the residual operator\n        dsigma = compute_stress(deps_flat)\n\n        jvp_field = self.space.ifft(\n            self.tensor_op.ddot(\n                self.Ghat, self.space.fft(dsigma.reshape(self.dofs_shape))\n            )\n        )\n        return jnp.real(jvp_field).reshape(-1)\n</code></pre> <pre><code>eps = make_field(dim=ndim, N=N, rank=2)\nresidual_fn = Residual(Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape)\njacobian_fn = Jacobian(Ghat=Ghat, space=space, tensor_op=tensor, dofs_shape=eps.shape)\n</code></pre> <pre><code>deps = make_field(dim=ndim, N=N, rank=2)\n\napplied_strains = jnp.diff(jnp.linspace(0, 2e-2, num=2))\n\n\nfor inc, deps_avg in enumerate(applied_strains):\n    # solving for elasticity\n    deps[:, :, 0, 0] = deps_avg\n    b = -residual_fn(deps)\n    eps = eps + deps\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_fn,\n        jacobian=jacobian_fn,\n        tol=1e-6,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-6,\n        krylov_max_iter=20,\n    )\n    eps = final_state[2]\n\n    print(\"step\", inc, \"time\", inc)\n\nsig = compute_stress(eps).reshape(dofs_shape)\n</code></pre> <pre><code>CG error = 0.22234152087832\nCG error = 0.00000045775788\nCG error = 0.00000001828671\nCG error = 0.00000000343622\nCG error = 0.00000000036042\nCG error = 0.00000000009831\nCG error = 0.00000000001393\nCG error = 0.00000000000470\nConverged, Residual value : 9.766911206116589e-07\nstep 0 time 0\n</code></pre> <p>Lets us now plot the stress tensor along the x-plane.</p> <pre><code>import matplotlib.pyplot as plt  # noqa: E402\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 4))\n\ncax1 = ax1.imshow(sig.at[:, :, int(N / 2), 0, 0].get(), cmap=\"managua_r\")\n\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(cax1, cax=cax, label=r\"$\\sigma_{xx}$\", orientation=\"horizontal\", location=\"top\")\n\n\ncax2 = ax2.imshow(sig.at[:, :, int(N / 2), 0, 1].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(cax2, cax=cax, label=r\"$\\sigma_{xy}$\", orientation=\"horizontal\", location=\"top\")\n\ncax3 = ax3.imshow(sig.at[:, :, int(N / 2), 1, 1].get(), cmap=\"managua_r\")\ndivider = make_axes_locatable(ax3)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(cax3, cax=cax, label=r\"$\\sigma_{yy}$\", orientation=\"horizontal\", location=\"top\")\n\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/multiscale/","title":"Multiscale problem: <code>xpektra</code> + <code>tatva</code>","text":"<p>In this example, we demonstrate how to solve a multiscale nonlinear elasticity problem using SpectralSolvers. We consider a macroscale domain with microscale heterogeneities and employ a two-scale approach to capture the material behavior accurately.</p> <p>At the microscale, we use <code>xpektra</code> to solve the RVE problem using spectral methods, while at the macroscale, we use <code>tatva</code> to solve the global problem using Finite Element Method (FEM).</p> <p>We couple the two scales by incorporating the microscale response into the macroscale energy functional.</p> <p>For memory efficiency, we use <code>jax.checkpoint</code> to reduce memory consumption during the RVE computations and <code>custom_linear_solve</code> to handle the differentiation through linear solves implicitly without unrolling each iteration.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_platforms\", \"cpu\")\nimport time\n\nimport equinox as eqx\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom skimage.morphology import disk\nfrom tatva import Mesh, Operator, element\nfrom tatva.plotting import plot_nodal_values\n\nfrom xpektra import FFTTransform, SpectralOperator, SpectralSpace, make_field\nfrom xpektra.projection_operator import GalerkinProjection\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    conjugate_gradient,\n    newton_krylov_solver,\n)\n</code></pre>"},{"location":"examples/multiscale/#defining-the-macroscale-problem-using-finite-element-method","title":"Defining the macroscale problem using Finite Element Method","text":"<p>Now let us see how we can construct the JVP function for a mechanical problem. We will use the same example of a square domain stretched in the \\(x\\)-direction.</p> <pre><code>mesh = Mesh.unit_square(2, 2)\n\nn_nodes = mesh.coords.shape[0]\nn_dofs_per_node = 2\nn_dofs = n_dofs_per_node * n_nodes\n</code></pre> <pre><code>plt.figure(figsize=(2, 2), layout=\"constrained\")\nplt.tripcolor(\n    *mesh.coords.T,\n    mesh.elements,\n    facecolors=np.ones(mesh.elements.shape[0]),\n    edgecolors=\"k\",\n    lw=0.2,\n    cmap=\"managua_r\",\n)\nplt.gca().set_aspect(\"equal\")\nplt.xlim(0, 1)\nplt.ylim(0, 1)\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/multiscale/#defining-microscale-problem-using-spectral-methods","title":"Defining microscale problem using Spectral methods","text":"<p>We now start with defining the microscale problem using spectral methods. We will use a square domain with periodic boundary conditions and define a two-phase composite material with different elastic moduli.</p> <pre><code>volume_fraction_percentage = 0.2\n\nlength = 0.1\nH, L = (99, 99)\n\ndx = length / H\ndy = length / L\n\nHmid = int(H / 2)\nLmid = int(L / 2)\nvol_inclusion = volume_fraction_percentage * (length * length)\nr = (\n    int(np.sqrt(vol_inclusion / np.pi) / dx) + 1\n)  # Since the rounding off leads to smaller fraction therefore we add 1.\n\n\nstructure = jnp.zeros((H, L))\nstructure = structure.at[Hmid - r : Hmid + 1 + r, Lmid - r : Lmid + 1 + r].add(disk(r))\n\nndim = len(structure.shape)\nN = structure.shape[0]\n\nplt.figure(figsize=(3, 3), layout=\"constrained\")\nplt.imshow(structure, cmap=\"managua\")\nplt.colorbar()\nplt.show()\n</code></pre> <p></p> <p>The material properties are defined as follows:</p> <pre><code>lambda_solid = 10\nmu_solid = 0.25\n\nlambda_inclusion = 1.0\nmu_inclusion = 2.5\n\nlambda_field = lambda_solid * (1 - structure) + lambda_inclusion * structure\nmu_field = mu_solid * (1 - structure) + mu_inclusion * structure\n</code></pre> <p>We can define our transform method to the spectral space, differential scheme, and projection operator.</p> <p>For this example, we will use a Rotated difference scheme, and a Galerkin projection.</p> <p>As in <code>xpektra</code>, we can define the spectral operator that enscapes the spectral transform, differential scheme, and tensor operations.</p> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=structure.shape, transform=fft_transform\n)\ndiff_scheme = RotatedDifference(space=space)\n\nspec_op = SpectralOperator(\n    scheme=diff_scheme,\n    space=space,\n)\n\ndofs_shape = make_field(dim=2, shape=structure.shape, rank=2).shape\n\nGhat = GalerkinProjection(scheme=diff_scheme)\n</code></pre>"},{"location":"examples/multiscale/#using-checkpoint-and-custom_linear_solve-for-memory-efficient-rve","title":"Using <code>checkpoint</code> and <code>custom_linear_solve</code> for memory-efficient RVE","text":"<p>To ease the implementation and handling of RVEs, we define a helper class <code>RVEMaterial</code> that will hold the RVE properties and methods to compute the residual and JVP and macroscale stresses from macroscale strains.</p> <p>A key point to note here is that the function <code>compute_macros_stress</code> is decorated with <code>jax.checkpoint</code>. This is done to avoid storing the entire computational graph during the forward pass, which can lead to high memory consumption. By using <code>jax.checkpoint</code>, we can trade off some computational time for reduced memory usage, which is particularly beneficial when dealing with large-scale problems or complex models. In simple terms, it tells JAX:</p> <p>\"During the forward pass, just run this function and store only its final output. During the backward pass (for the gradient), don't look up the stored history\u2014just re-run the entire function from scratch to get the values you need.\"</p> <p>Another important aspect is the custom <code>conjugate_gradient</code> which uses <code>jax.lax.custom_linear_solve</code> to define a linear solver with a implicit differentiation. This allows JAX to not unroll the entire CG iterations during backpropagation, leading to significant memory savings. Basically, on the backward pass, JAX knows that to get the gradient, it just needs to call the transpose_solve function to solve the adjoint system \\(A^T\\lambda=g\\) at the converged solution, without needing to remember all the intermediate steps of the CG iterations.</p> <pre><code>class RVEMaterial(eqx.Module):\n    \"\"\"A simple linear elastic material model.\"\"\"\n\n    mu: Array\n    lmbda: Array\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def compute_strain_energy(self, eps_flat: Array) -&gt; Array:\n        eps = eps_flat.reshape(self.dofs_shape)\n        eps_sym = 0.5 * (eps + spec_op.trans(eps))\n        energy = 0.5 * jnp.multiply(\n            self.lmbda, spec_op.trace(eps_sym) ** 2\n        ) + jnp.multiply(self.mu, spec_op.trace(spec_op.dot(eps_sym, eps_sym)))\n        return energy.sum()\n\n    @eqx.filter_jit\n    def compute_rve_stress(self, eps_flat: Array) -&gt; Array:\n        return jax.jacrev(self.compute_strain_energy)(eps_flat)\n\n    @eqx.filter_jit\n    def jacobian(self, eps_flat: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        eps_flat = eps_flat.reshape(-1)\n        sigma = self.compute_rve_stress(eps_flat)\n        residual_field = spec_op.inverse(\n            Ghat.project(spec_op.forward(sigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(residual_field).reshape(-1)\n\n    @eqx.filter_jit\n    def hessian(self, deps_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n\n        deps_flat = deps_flat.reshape(-1)\n        dsigma = self.compute_rve_stress(deps_flat)\n        jvp_field = spec_op.inverse(\n            Ghat.project(spec_op.forward(dsigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(jvp_field).reshape(-1)\n\n    # @partial(jax.checkpoint, static_argnums=(0,))\n    @eqx.filter_jit\n    def compute_macro_stress(self, macro_strain):\n        # set macroscopic loading\n        DE = jnp.array(make_field(dim=2, shape=structure.shape, rank=2))\n        DE = DE.at[:, :, 0, 0].set(macro_strain[0, 0])\n        DE = DE.at[:, :, 1, 1].set(macro_strain[1, 1])\n        DE = DE.at[:, :, 0, 1].set(macro_strain[0, 1])\n        DE = DE.at[:, :, 1, 0].set(macro_strain[1, 0])\n\n        # initial residual: distribute \"DE\" over grid using \"K4\"\n        b = -self.jacobian(DE)\n\n        eps = newton_krylov_solver(\n            x=DE,\n            b=b,\n            gradient=self.jacobian,\n            jacobian=self.hessian,\n            tol=1e-8,\n            max_iter=20,\n            krylov_solver=conjugate_gradient,\n            krylov_tol=1e-8,\n            krylov_max_iter=20,\n        )\n\n        rve_sig = self.compute_rve_stress(eps)\n\n        # get the macro stress\n        macro_sigma = jnp.sum(rve_sig * dx * dy, axis=(0, 1)) / (length**2)\n\n        del rve_sig\n\n        return macro_sigma\n\n    def compute_tangent(self, macro_strain):\n        tangent = jax.jacfwd(self.compute_macro_stress)\n        return tangent(macro_strain)\n</code></pre> <p>Now  we can define our rve material with the defined structure and material properties.</p> <pre><code>rvematerial = RVEMaterial(mu=mu_field, lmbda=lambda_field, dofs_shape=dofs_shape)\n</code></pre>"},{"location":"examples/multiscale/#defining-the-energy-functional-at-macroscale","title":"Defining the energy functional at macroscale","text":"<p>We now define the total energy functional at the macroscale. This functional computes the total energy of the system given the macroscale strain and macroscale stress computed from the RVE material.</p> \\[ \\Psi_\\text{macro} =\\int \\frac{1}{2} \\sigma(\\varepsilon_\\text{macro}) : \\varepsilon_\\text{macro} ~d\\text{V} \\] <p>where \\(\\sigma(\\varepsilon_\\text{macro})\\) is the macroscale stress computed from the RVE material given the macroscale strain \\(\\varepsilon_\\text{macro}\\). T To compute the \\(\\sigma(\\varepsilon_\\text{macro})\\) we make use of the homogenized tangent computed from the RVE material.</p> \\[ \\sigma(\\varepsilon_\\text{macro}) = \\mathbb{C}_\\text{macro} : \\varepsilon_\\text{macro} \\] <p>the macroscale strain is computed from the macroscale displacement gradient.</p> \\[ \\varepsilon_\\text{macro} = \\frac{1}{2} (\\nabla u + \\nabla u^T) \\] <pre><code>tri = element.Tri3()\nop = Operator(mesh, tri)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u: Array) -&gt; Array:\n    \"\"\"Compute the strain tensor from the gradient of the displacement.\"\"\"\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(grad_u=2)\ndef strain_energy(grad_u: Array) -&gt; Array:\n    \"\"\"Compute the strain energy density.\"\"\"\n    eps = compute_strain(grad_u)\n    tangent = rvematerial.compute_tangent(eps)\n    sig = jnp.einsum(\"ijkl, kl-&gt;ij\", tangent, eps)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sig, eps)\n\n\n@jax.jit\ndef total_energy(u_flat):\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_grad = op.grad(u)\n    energy_density = strain_energy(u_grad)\n    return op.integrate(energy_density)\n\n\ngradient = jax.jacrev(total_energy)\n\n@eqx.filter_jit\ndef compute_gradient(u):\n    u_flat = u.reshape(-1)\n    grad = gradient(u_flat)\n    return grad, grad\n\ngradient_with_hessian = jax.jacfwd(compute_gradient, has_aux=True)\n</code></pre> <p>The above was coupling the macroscale and microscale. The use of JAX's automatic differentiation and custom linear solvers allows us to efficiently compute the necessary derivatives necessary for linking the two scales together.</p> <p>We can now solve the macroscale problem for a given set of boundary conditions and loading using the defined energy functional and the RVE material.</p> <pre><code>left_nodes = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nright_nodes = jnp.where(jnp.isclose(mesh.coords[:, 0], 1.0))[0]\nfixed_dofs = jnp.concatenate(\n    [\n        2 * left_nodes,\n        2 * left_nodes + 1,\n        2 * right_nodes,\n    ]\n)\nprescribed_values = jnp.zeros(n_dofs).at[2 * right_nodes].set(0.3)\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"examples/multiscale/#using-newtons-method-at-macroscale","title":"Using Newton's method at macroscale","text":"<p>At macroscale we use Newton's method with the Newton-Raphson method with a direct linear solver to solve the linearized system at each Newton iteration. Below we define the Newton solver. The boundary conditions are applied at each iteration using the lifting approach.</p> <pre><code>def newton_solver(\n    u,\n    fext,\n    fixed_dofs,\n):\n    K, fint = gradient_with_hessian(u)\n\n    du = jnp.zeros_like(u)\n\n    iiter = 0\n    norm_res = 1.0\n\n    tol = 1e-8\n    max_iter = 10\n\n    while norm_res &gt; tol and iiter &lt; max_iter:\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n\n        print(\"assembling linear system\")\n\n        #K = hessian(u)\n        K_lifted = K.at[jnp.ix_(free_dofs, fixed_dofs)].set(0.0)\n        K_lifted = K_lifted.at[jnp.ix_(fixed_dofs, free_dofs)].set(0.0)\n        K_lifted = K_lifted.at[jnp.ix_(fixed_dofs, fixed_dofs)].set(\n            jnp.eye(len(fixed_dofs))\n        )\n        du = jnp.linalg.solve(K_lifted, residual)\n\n        u = u.at[:].add(du)\n        K, fint = gradient_with_hessian(u)\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n        norm_res = jnp.linalg.norm(residual)\n        print(f\"Macroscale  Residual: {norm_res:.2e}\")\n        iiter += 1\n\n    return u, norm_res\n</code></pre>"},{"location":"examples/multiscale/#solving-the-macroscale-problem","title":"Solving the macroscale problem","text":"<p>We can now solve the macroscale problem using Newton's method with the newton raphson method with a direct linear solver.</p> <pre><code>u = jnp.zeros(n_dofs)\nfext = jnp.zeros(n_dofs)\n\nn_steps = 1\n\ndu_total = prescribed_values / n_steps  # displacement increment\n\n\nstart_time = time.time()\n\nfor step in range(n_steps):\n    print(f\"Step {step + 1}/{n_steps}\")\n    u = u.at[fixed_dofs].set((step + 1) * du_total[fixed_dofs])\n\n    u_new, rnorm = newton_solver(\n        u,\n        fext,\n        fixed_dofs,\n    )\n\n    u = u_new\n\n\nu = u.at[fixed_dofs].set(prescribed_values.at[fixed_dofs].get())\n\nend_time = time.time()\nprint(f\"Total time taken: {end_time - start_time:.2f} seconds\")\n\nu_solution = u.reshape(n_nodes, n_dofs_per_node)\nprint(\"Final displacement field:\\n\", u_solution)\n</code></pre> <pre><code>Step 1/1\nConverged, Residual value : 8.35888085015558e-09\nConverged, Residual value : 0.0\nDidnot converge, Residual value : 8.35888085015558e-09\nDidnot converge, Residual value : 8.35888085015558e-09\nConverged, Residual value : 8.35888085015558e-09\nConverged, Residual value : 8.35888085015558e-09\nConverged, Residual value : 0.0\nDidnot converge, Residual value : 0.0\nDidnot converge, Residual value : 0.0\nDidnot converge, Residual value : 8.35888085015558e-09\nConverged, Residual value : 0.0\nConverged, Residual value : 0.0\nConverged, Residual value : 8.35888085015558e-09\nDidnot converge, Residual value : 0.0\nDidnot converge, Residual value : 0.0\nDidnot converge, Residual value : 8.35888085015558e-09\nassembling linear system\nDidnot converge, Residual value : 8.21943687854892e-09\nConverged, Residual value : 9.703063929747395e-09\nConverged, Residual value : 8.951874271943062e-09\nConverged, Residual value : 7.283241686478165e-09\nDidnot converge, Residual value : 9.703063929747395e-09\nDidnot converge, Residual value : 8.951874271943062e-09\nDidnot converge, Residual value : 7.283241686478165e-09\nConverged, Residual value : 8.733637047568312e-09\nConverged, Residual value : 8.21943687854892e-09\nConverged, Residual value : 9.595111311882397e-09\nDidnot converge, Residual value : 8.733637047568312e-09\nDidnot converge, Residual value : 9.595111311882397e-09\nConverged, Residual value : 5.863420139825045e-09\nDidnot converge, Residual value : 5.863420139825045e-09\nConverged, Residual value : 7.210627233209128e-09\nDidnot converge, Residual value : 7.210627233209128e-09\nMacroscale  Residual: 1.75e-01\nassembling linear system\nConverged, Residual value : 7.509238104805355e-09\nDidnot converge, Residual value : 7.509238104805355e-09\nConverged, Residual value : 8.117263598654781e-09\nDidnot converge, Residual value : 8.302637617206848e-09\nDidnot converge, Residual value : 8.117263598654781e-09\nConverged, Residual value : 6.987551908831712e-09\nConverged, Residual value : 8.302637617206848e-09\nDidnot converge, Residual value : 6.987551908831712e-09\nConverged, Residual value : 6.200103744387165e-09\nConverged, Residual value : 8.224163898569997e-09\nConverged, Residual value : 5.881897786335455e-09\nDidnot converge, Residual value : 6.200103744387165e-09\nDidnot converge, Residual value : 5.881897786335455e-09\nDidnot converge, Residual value : 8.224163898569997e-09\nConverged, Residual value : 7.787001773078677e-09\nDidnot converge, Residual value : 7.787001773078677e-09\nMacroscale  Residual: 2.09e-12\nTotal time taken: 54.94 seconds\nFinal displacement field:\n [[ 0.          0.        ]\n [ 0.          0.        ]\n [ 0.          0.        ]\n [ 0.17580192  0.18192094]\n [ 0.10322377  0.01598389]\n [ 0.08660838 -0.12469517]\n [ 0.3         0.17344635]\n [ 0.3         0.06082025]\n [ 0.3        -0.11669975]]\n</code></pre>"},{"location":"examples/multiscale/#post-processing","title":"Post-processing","text":"<p>Now we can plot the displacement at the macroscale.</p> <pre><code>fig = plt.figure(figsize=(6, 4), layout=\"constrained\")\nax = plt.axes()\n\nplot_nodal_values(\n    coords=mesh.coords,\n    elements=mesh.elements,\n    values=u_solution[:, 0].flatten(),\n    u=u_solution,\n    ax=ax,\n    label=r\"$u_y$\",\n    shading=\"flat\",\n    edgecolors=\"black\",\n)\nax.set_xlabel(r\"x\")\nax.set_ylabel(r\"y\")\nax.set_aspect(\"equal\")\n\nax.margins(0, 0)\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/phasefield_fracture_2D/","title":"phasefield fracture 2D","text":"<pre><code>import jax\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_platforms\", \"cpu\")\nimport jax.numpy as jnp\n\nimport numpy as np\nimport equinox as eqx\nimport matplotlib.pyplot as plt\nfrom skimage.morphology import footprint_rectangle\n</code></pre> <pre><code>from xpektra import SpectralSpace, make_field\nfrom xpektra.transform import FFTTransform\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.scheme import FourierScheme, RotatedDifference\nfrom xpektra.projection_operator import GalerkinProjection\n\n\nfrom xpektra.solvers.nonlinear import newton_krylov_solver, conjugate_gradient_while\n</code></pre> <pre><code>N = 99\nndim = 2\nlength = 10\ndx = length / N\nell = 0.2\n</code></pre> <pre><code>def create_structure(N):\n    Hmid = int(N / 2)\n    Lmid = int(N / 2)\n    r = int(N / 10)\n\n    structure = np.zeros((N, N))\n    structure[Hmid : Hmid + 1, Lmid - 2 * r : Lmid + 2 * r] += footprint_rectangle(\n        (1, 4 * r)\n    )\n\n    return structure\n\n\nstructure = create_structure(N)\nplt.figure(figsize=(4, 4))\ncb = plt.imshow(structure, cmap=\"gray\")\nplt.colorbar(cb)\nplt.show()\n</code></pre> <p>Spatial and FFT operators that we need for solving of frature problem. </p> <pre><code>fft_transform = FFTTransform(ndim)\nspace = SpectralSpace(shape=(N, N), lengths=(length, length), transform=fft_transform)\ndiff_scheme = RotatedDifference(space=space)\nop = SpectralOperator(scheme=diff_scheme, space=space)\n</code></pre> <p>The total energy of the material undergoing fracture can be given as </p> \\[\\begin{align} \\psi(\\varepsilon_{ij}) &amp;= \\psi_{elastic} + \\psi_{fracture} \\\\ \\psi &amp;= g(\\alpha)\\psi_{e}^{+} + \\psi_{e}^{-} + \\dfrac{G_{c}}{c_w}(\\dfrac{w(\\alpha)}{l} + l|\\nabla\\alpha|^{2}) \\end{align}\\] <p>Defining the elastic strain energy with degradation of only <code>positive</code> energy part, we use the <code>volumetric-deviatoric</code> split to define the positive and negative part.</p>"},{"location":"examples/phasefield_fracture_2D/#elasticity-subproblem","title":"Elasticity subproblem","text":"<p>Now, we divided the problem into two subproblems: elastic and fracture. taking the first variation of functional \\(\\psi\\) with respect to \\(\\varepsilon\\) and \\(\\alpha\\). The first  variation of functional \\(F[u]\\) is defined as :</p> <p>\\begin{align} \\delta F[u] &amp;= \\lim_{\\epsilon\\to 0} \\dfrac{F[u+\\epsilon\\delta u] - F[u]}{\\epsilon} = \\lim_{\\epsilon\\to0} \\dfrac{\\text{d}}{\\text{d}\\epsilon} I[u+\\epsilon\\delta u] \\end{align} The above is also called Gateaux derivative. </p> <p>For functional form that may involve \\(u\\) as well as  its partial derivatives, we can define the first variation as follows:</p> \\[\\begin{align} I[u] &amp;= \\int f(u, \\nabla u, ...) dV \\to \\delta I[u] = \\int \\big( \\dfrac{\\partial f}{\\partial u_i}\\delta u_{i} + \\dfrac{\\partial f}{\\partial u_{i,j}}\\delta u_{i, j} + ....\\big) dV  \\end{align}\\] <p>The first variation of \\(\\psi\\) with respect to \\(\\varepsilon\\)</p> \\[\\begin{align} \\delta \\psi(\\varepsilon) &amp;= \\int \\dfrac{\\partial \\psi}{\\partial \\varepsilon}\\delta\\varepsilon dV \\\\ &amp;= \\int \\underbrace{\\Big(g(\\alpha) \\dfrac{\\partial \\psi_e^{+}}{\\partial \\varepsilon} + \\dfrac{\\partial \\psi_{e}^{-}}{\\partial \\varepsilon}\\Big)}_{\\sigma}\\delta \\varepsilon dV \\end{align}\\] <p>For this subproblem,we solve the weak form given as </p> \\[\\delta \\psi(\\epsilon) = \\int \\sigma \\delta \\epsilon dV = 0\\] <p>and we use  the Fourier-Galerkin method for that. </p> <p>For FFT scheme, we define the above strain expression for each grid point (\\(x,y\\))</p> \\[\\psi_{xy} = \\dfrac{1}{2}(\\text{tr}(\\varepsilon_{iixy})^2 + \\mu \\text{tr}(\\varepsilon_{ijxy}\\varepsilon_{jkxy} ) $$ $$\\sigma_{ijxy} = \\dfrac{\\partial \\psi_{xy}}{\\partial \\varepsilon_{ijxy}}\\] <pre><code>E_solid = 1.\nE_void = 1e-3\nnu = 0.3\n\nGc = 1e-2\nlambda_solid = E_solid * nu / ((1 + nu) * (1 - 2 * nu))\nlambda_void = E_void * nu / ((1 + nu) * (1 - 2 * nu))\nmu_solid = E_solid / (2 * (1 + nu))\nmu_void = E_void / (2 * (1 + nu))\n\nlambda_field = lambda_solid * (1-structure) + lambda_void * structure\nmu_field = mu_solid * (1-structure) + mu_void * structure\nbulk_field = lambda_field + 2 * mu_field / 3\n\n\nelasticity_dofs_shape = make_field(dim=ndim, shape=(N, N), rank=2).shape\nfracture_dofs_shape = make_field(dim=ndim, shape=(N, N), rank=0).shape\n</code></pre> <pre><code>i = jnp.eye(ndim)\nI = make_field(dim=ndim, shape=(N, N), rank=2) + i\n\ncw = 2 / 3.0\nkappa = 1e-1\n\n\n@jax.jit\ndef g(alpha):\n    return (1 - alpha) ** 2 + kappa\n\n\n@jax.jit\ndef w(alpha):\n    return alpha  # 0.5*alpha**2 # alpha\n\n\n@jax.jit\ndef no_split(eps):\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    energy = 0.5 * jnp.multiply(lambda_field, op.trace(eps_sym) ** 2) + jnp.multiply(\n        mu_field, op.trace(op.dot(eps_sym, eps_sym))\n    )\n    return energy\n\n\n@jax.jit\ndef vol_dev_split(eps):\n    def macluay_plus(A):\n        return 0.5 * (A + jnp.abs(A))\n\n    def macluay_minus(A):\n        return 0.5 * (A - jnp.abs(A))\n\n    esp_plus = macluay_plus(op.trace(eps))\n    esp_minus = macluay_minus(op.trace(eps))\n    eps_dev = (\n        eps - jnp.einsum(\"ij, ...-&gt;...ij\", jnp.eye(ndim), op.trace(eps)) / 3\n    )  # deviatoric strain\n\n    strain_energy_plus = 0.5 * jnp.multiply(\n        bulk_field, jnp.multiply(esp_plus, esp_plus)\n    ) + jnp.multiply(mu_field, op.ddot(eps_dev, eps_dev))\n    strain_energy_minus = 0.5 * jnp.multiply(\n        mu_field, jnp.multiply(esp_minus, esp_minus)\n    )\n\n    return strain_energy_plus, strain_energy_minus\n\n\n@jax.jit\ndef spectral_split(eps):\n    def macluay_plus(A):\n        return 0.5 * (A + jnp.abs(A))\n\n    def macluay_minus(A):\n        return 0.5 * (A - jnp.abs(A))\n\n    eps_eg = jnp.linalg.eig(eps)\n\n\n@jax.jit\ndef strain_energy(eps_flat, alpha_flat):\n    eps = eps_flat.reshape(elasticity_dofs_shape)\n    alpha = alpha_flat.reshape(fracture_dofs_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    strain_energy_plus, strain_energy_minus = vol_dev_split(eps_sym)\n    energy = g(alpha) * strain_energy_plus + strain_energy_minus\n    # strain_energy = no_split(eps_sym)\n    # energy = g(alpha)*strain_energy\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre> <pre><code>Ghat = GalerkinProjection(scheme=diff_scheme)\n</code></pre> <pre><code>from jax import Array\n\nclass ElasticityResidual(eqx.Module):\n    \"\"\"A callable module that computes the residual vector.\"\"\"\n\n    dofs_shape: tuple = eqx.field(static=True)\n\n    # We can even pre-define the stress function if it's always the same\n    # For this example, we'll keep your original `compute_stress` function\n    # available in the global scope.\n\n    @eqx.filter_jit\n    def __call__(self, eps_flat: Array, alpha_flat: Array) -&gt; Array:\n        \"\"\"\n        This makes instances of this class behave like a function.\n        It takes only the flattened vector of unknowns, as required by the solver.\n        \"\"\"\n        eps_flat = eps_flat.reshape(-1)\n        alpha_flat = alpha_flat.reshape(-1)\n        sigma = compute_stress(eps_flat, alpha_flat)\n        residual_field = op.inverse(\n            Ghat.project(op.forward(sigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(residual_field).reshape(-1)\n\n\nclass ElasticityJacobian(eqx.Module):\n    \"\"\"A callable module that represents the Jacobian operator (tangent).\"\"\"\n\n    dofs_shape: tuple = eqx.field(static=True)\n\n    @eqx.filter_jit\n    def __call__(self, deps_flat: Array, alpha_flat: Array) -&gt; Array:\n        \"\"\"\n        The Jacobian is a linear operator, so its __call__ method\n        represents the Jacobian-vector product.\n        \"\"\"\n\n        deps_flat = deps_flat.reshape(-1)\n        alpha_flat = alpha_flat.reshape(-1)\n        dsigma = compute_stress(deps_flat, alpha_flat)\n        jvp_field = op.inverse(\n            Ghat.project(op.forward(dsigma.reshape(self.dofs_shape)))\n        )\n        return jnp.real(jvp_field).reshape(-1)\n</code></pre> <pre><code>alpha0    = structure \n\napplied_strains = jnp.diff(jnp.linspace(0, 1e-3, num=2))\n\ndeps = make_field(dim=ndim, shape=structure.shape, rank=2)\neps = make_field(dim=ndim, shape=structure.shape, rank=2)\n\nresidual_fn = ElasticityResidual(dofs_shape=eps.shape)\njacobian_fn = ElasticityJacobian(dofs_shape=eps.shape)\n\n\nfor inc, deps_avg in enumerate(applied_strains):\n\n    # solving for elasticity\n    deps[:, :, 0, 0] = deps_avg\n\n    b = -jacobian_fn(deps.reshape(-1), alpha_flat=alpha0.reshape(-1))\n    eps = eps + deps\n\n\n    residual_partial = eqx.Partial(residual_fn, alpha_flat=alpha0.reshape(-1))\n    jacobian_partial = eqx.Partial(jacobian_fn, alpha_flat=alpha0.reshape(-1))\n\n    final_state = newton_krylov_solver(\n        state=(deps, b, eps),\n        gradient=residual_partial,\n        jacobian=jacobian_partial,\n        tol=1e-8,\n        max_iter=20,\n        krylov_solver=conjugate_gradient_while,\n        krylov_tol=1e-8,\n        krylov_max_iter=50,\n    )\n    eps = final_state[2]\n\neps = final_state[2].reshape(elasticity_dofs_shape)\nsig = compute_stress(final_state[2], alpha_flat=alpha0.reshape(-1)).reshape(elasticity_dofs_shape)\n</code></pre> <pre><code>CG error = 0.00006655978748\n</code></pre> <pre><code>CG error = 0.00042089973622\nCG error = 0.00007554364467\nCG error = 0.00001522675664\nCG error = 0.00000352423017\nCG error = 0.00000077934000\nCG error = 0.00000017491980\nCG error = 0.00000003847124\nCG error = 0.00000000975842\nCG error = 0.00000000225270\nCG error = 0.00000000055261\nCG error = 0.00000000012713\nCG error = 0.00000000003065\nCG error = 0.00000000000702\nCG error = 0.00000000000166\nCG error = 0.00000000000038\nCG error = 0.00000000000009\nCG error = 0.00000000000002\nCG error = 0.00000000000000\nCG error = 0.00000000000000\nDidnot converge, Residual value : 2.3441717668617714e-08\n</code></pre> <pre><code>fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4))\ncb = ax1.imshow(sig.at[:, :, 0, 0].get(), cmap=\"managua\", origin='lower')\nfig.colorbar(cb, ax=ax1)\n\nax2.plot(sig.at[:, :, 0, 0].get()[N//2, :])\nplt.show()\n</code></pre> <p></p> <pre><code>op.grad(alpha0).shape\n</code></pre> <pre><code>(99, 99, 2)\n</code></pre>"},{"location":"examples/phasefield_fracture_2D/#phasefield-subproblem","title":"phasefield subproblem","text":"<p>The first variation of \\(\\psi\\) with respect to \\(\\alpha\\) </p> \\[\\begin{align} \\delta \\psi(\\alpha) &amp;= \\int \\big( \\dfrac{\\partial \\psi}{\\partial \\alpha}\\delta \\alpha + \\dfrac{\\partial \\psi}{\\partial \\nabla \\alpha}\\delta \\nabla \\alpha \\big) dV \\\\ &amp;= \\int \\Big ( \\psi_{e}^{+}\\dfrac{\\partial g(\\alpha)}{\\partial \\alpha}\\delta \\alpha + \\dfrac{G_{c}}{c_w}\\dfrac{1}{l}\\dfrac{\\partial w(\\alpha)}{\\partial \\alpha}\\delta \\alpha + 2\\dfrac{G_{c}}{c_w}\\nabla\\alpha \\delta\\nabla \\alpha\\Big) dV \\end{align}\\] <p>We can apply intergation by parts to the last term</p> \\[ \\int \\nabla \\alpha \\delta \\nabla \\alpha dV =  \\nabla \\alpha \\delta \\alpha |_{\\Gamma} - \\int \\nabla ( \\nabla \\alpha ) \\delta \\alpha~ dV  \\] <p>and since \\(\\delta \\alpha=0\\) at the boundaries we can say that the first variation of \\(\\psi\\) w.r.t \\(\\alpha\\)</p> \\[ \\delta \\psi(\\alpha) =  \\int \\Big ( \\psi_{e}^{+}\\dfrac{\\partial g(\\alpha)}{\\partial \\alpha} + \\dfrac{G_{c}}{c_w}\\dfrac{1}{l}\\dfrac{\\partial w(\\alpha)}{\\partial \\alpha} - 2\\ell\\dfrac{G_{c}}{c_w}\\nabla \\cdot{} \\nabla \\alpha  \\Big) \\delta \\alpha dV = 0\\] <p>For this subproblem we chose to solve the strong form rather than the above weak form. The strong form is given from the above weak form. Since the above equation holds for any \\(\\delta \\alpha\\) therefore, we can say </p> \\[ \\psi_{e}^{+}\\dfrac{\\partial g(\\alpha)}{\\partial \\alpha} + \\dfrac{G_{c}}{c_w}\\dfrac{1}{l}\\dfrac{\\partial w(\\alpha)}{\\partial \\alpha} - 2\\ell \\dfrac{G_{c}}{c_w}\\nabla \\cdot{} \\nabla \\alpha = 0 \\] <p>We use <code>AT1</code> phasefield formulation for the phasefield degradation function. </p> <pre><code>@jax.jit\ndef g_sum(alpha):\n    return g(alpha).sum()\n\n\n@jax.jit\ndef w_sum(alpha):\n    return w(alpha).sum()\n\n\ndgdalpha = jax.jit(jax.grad(g_sum))\ndwdalpha = jax.jit(jax.grad(w_sum))\n\n\n@jax.jit\ndef fracture_energy(alpha_flat, eps_flat):\n    eps = eps_flat.reshape(elasticity_dofs_shape)\n    alpha = alpha_flat.reshape(fracture_dofs_shape)\n    eps_sym = 0.5 * (eps + op.trans(eps))\n    strain_energy_plus, _ = vol_dev_split(eps_sym)\n    elastic_energy = g(alpha) * strain_energy_plus\n\n    energy = (\n        elastic_energy\n        + jnp.multiply(Gc, w(alpha)) / cw\n        + jnp.multiply(\n            Gc,\n            ell * ell * jnp.einsum(\"...ij,...ij-&gt;...\", op.grad(alpha), op.grad(alpha)),\n        )\n        / cw\n    )\n    # strain_energy = no_split(eps_sym)\n    # energy = g(alpha)*strain_energy\n    return energy.sum()\n\n\n@jax.jit\ndef fracture_strong_form(alpha, epsilon):\n    alpha = alpha.reshape((N, N))\n\n    eps_sym = 0.5 * (epsilon + op.trans(epsilon))\n    strain_energy_plus, _ = vol_dev_split(eps_sym)\n\n    res = (\n        jnp.multiply(strain_energy_plus, dgdalpha(alpha))\n        + jnp.multiply(Gc, dwdalpha(alpha)) / ell / cw\n        - 2 * ell * jnp.multiply(Gc, op.laplacian(alpha)) / cw\n    )\n    return res.reshape(-1)\n</code></pre> <p>The phasefield subproblem is a root-finding problem under cosntraints and is given as </p> <p>Find $\\alpha $ for a given \\(\\varepsilon\\) such that $$ \\psi_{e}^{+}\\dfrac{\\partial g(\\alpha)}{\\partial \\alpha} + \\dfrac{G_{c}}{c_w}\\dfrac{1}{l}\\dfrac{\\partial w(\\alpha)}{\\partial \\alpha} - 2\\ell\\dfrac{G_{c}}{c_w}\\nabla \\cdot{} \\nabla \\alpha = 0 $$</p> <p>and the constraint is $\\alpha_\\textsf{prev} &lt; \\alpha &lt; 1 $ for irreversibility.</p> <pre><code>fracture_energy(alpha0.reshape(-1), eps.reshape(-1))\n</code></pre> <pre><code>Array(419.71454456, dtype=float64)\n</code></pre> <pre><code>from scipy.optimize import minimize, Bounds\n</code></pre> <pre><code>@eqx.filter_jit\ndef least_squares_objective(alpha, F_func):\n    \"\"\"\n    Computes the scalar objective: 1/2 * ||F(alpha)||^2\n\n    Args:\n        alpha: The input vector\n        F_func: Your original function that returns the residual vector\n    \"\"\"\n    residual_vector = F_func(alpha)\n    return 0.5 * jnp.dot(residual_vector, residual_vector)\n\nF = eqx.Partial(fracture_strong_form, epsilon=eps)\n\nleast_squares_objective_partial = eqx.Partial(least_squares_objective, F_func=F)\n\nfracture_energy_partial = eqx.Partial(fracture_energy, eps_flat=eps.reshape(-1))\n</code></pre> <pre><code>from scipy.optimize import minimize, Bounds\n\n\n# 2. Create the combined value-and-gradient function\n#    This is the key to connecting JAX to SciPy.\n#\n#    NOTE: F_func is passed as a static argument because\n#    it's a Python function, not a JAX array.\nvalue_and_grad_jax = jax.jit(jax.value_and_grad(least_squares_objective_partial))\n\n\n# 3. Create a wrapper for SciPy\n#    SciPy solvers expect functions that:\n#    - Accept a 1D NumPy float64 array.\n#    - Return NumPy float64s.\n#    This wrapper handles the type conversions.\ndef scipy_objective_and_grad(alpha_np):\n    \"\"\"\n    Wrapper for SciPy to call our JIT-compiled JAX function.\n    \"\"\"\n    # Convert NumPy input to JAX array\n    alpha_jax = jnp.asarray(alpha_np)\n\n    # Call the JAX function\n    value_jax, grad_jax = value_and_grad_jax(alpha_jax)\n    #value_jax = least_squares_objective_partial(alpha_jax)\n    #grad_jax = F(alpha_jax)\n\n    # Convert JAX outputs back to NumPy float64\n    value_np = np.float64(value_jax)\n    grad_np = np.array(grad_jax, dtype=np.float64)\n\n    return value_np, grad_np\n\n\n# SciPy L-BFGS-B works best with float64\n# Ensure your initial guess is a flat NumPy array\nalpha0_np = np.array(alpha0, dtype=np.float64).flatten()\n\n# Create the SciPy Bounds object\nscipy_bounds = Bounds(alpha0.reshape(-1), jnp.ones_like(alpha0).reshape(-1))\n\nprint(\"Starting scipy.optimize.minimize (L-BFGS-B) with JAX gradient...\")\n\n# Run the solver!\n# - fun: The wrapper function\n# - x0: Initial guess\n# - args: Extra arguments to pass to our wrapper (F_func)\n# - method: The solver that worked for you\n# - jac=True: Tells SciPy that 'fun' returns (value, gradient)\n# - bounds: The constraints\n# - options: Set 'disp' to True for verbose output\nresult = minimize(\n    fun=scipy_objective_and_grad,\n    x0=alpha0_np,\n    method=\"L-BFGS-B\",\n    jac=True,\n    bounds=scipy_bounds,\n    options={\"disp\": True, \"maxiter\": 500},\n)\n\n# --- 5. Check the results ---\nprint(\"\\n--- SciPy Results ---\")\nprint(f\"Success: {result.success}\")\nprint(f\"Message: {result.message}\")\nprint(f\"Final objective (1/2 ||F||^2): {result.fun}\")\nfinal_F_norm = jnp.sqrt(2 * result.fun)\nprint(f\"Final residual norm ||F||: {final_F_norm}\")\nprint(F(result.x).reshape((N, N)))\n\n# The final solution vector\nfinal_alpha = result.x\n</code></pre> <pre><code>Starting scipy.optimize.minimize (L-BFGS-B) with JAX gradient...\n</code></pre> <pre><code>/tmp/ipykernel_5369/2471087639.py:53: DeprecationWarning: scipy.optimize: The `disp` and `iprint` options of the L-BFGS-B solver are deprecated and will be removed in SciPy 1.18.0.\n  result = minimize(\n</code></pre> <pre><code>--- SciPy Results ---\nSuccess: True\nMessage: CONVERGENCE: RELATIVE REDUCTION OF F &lt;= FACTR*EPSMCH\nFinal objective (1/2 ||F||^2): 27.516645377736474\nFinal residual norm ||F||: 7.41844260983887\n[[0.0748839  0.07488408 0.07488441 ... 0.07488408 0.0748839  0.07488383]\n [0.07488384 0.07488405 0.07488435 ... 0.07488405 0.07488384 0.0748838 ]\n [0.07488377 0.07488393 0.07488428 ... 0.07488393 0.07488377 0.07488368]\n ...\n [0.07488377 0.07488393 0.07488428 ... 0.07488393 0.07488377 0.07488368]\n [0.07488384 0.07488405 0.07488435 ... 0.07488405 0.07488384 0.0748838 ]\n [0.0748839  0.07488408 0.07488441 ... 0.07488408 0.0748839  0.07488383]]\n</code></pre> <pre><code>plt.imshow(final_alpha.reshape((N, N)), cmap=\"managua\")\nplt.colorbar()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/phasefield_fracture_2D/#using-jaxopt","title":"using jaxopt","text":"<pre><code>from jaxopt import ProjectedGradient\nfrom jaxopt import ScipyBoundedMinimize # &lt;-- Alternative, see below\nfrom jaxopt.projection import projection_box\n</code></pre> <pre><code># We need a new function that returns a scalar to be *minimized*.\n# The standard choice is the sum of squares of the residual.\n\n@eqx.filter_jit\ndef least_squares_objective(alpha, F_func):\n    \"\"\"\n    Computes the scalar objective: 1/2 * ||F(alpha)||^2\n\n    Args:\n        alpha: The input vector\n        F_func: Your original function that returns the residual vector\n    \"\"\"\n    residual_vector = F_func(alpha)\n    return 0.5 * jnp.dot(residual_vector, residual_vector)\n</code></pre> <pre><code># --- Create the bounds tuple ---\nbounds = (structure.reshape(-1), jnp.ones(N*N))\n\nleast_squares_objective_partial = eqx.Partial(least_squares_objective, F_func=F)\n</code></pre> <pre><code>lbfgsb = ScipyBoundedMinimize(\n    fun=least_squares_objective_partial,\n    method=\"L-BFGS-B\",\n    maxiter=500,\n    tol=1e-6,\n    options={'disp': True} # Show SciPy's output\n)\n\n# 'sol' will contain the final 'alpha' and solver state\nsol_scipy, state_scipy = lbfgsb.run(\n    init_params=alpha0.reshape(-1),\n    bounds=bounds,\n)\n\nprint(state_scipy.success)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>plt.figure(figsize=(4, 4))\ncb = plt.imshow(sol_scipy.reshape((N, N)), cmap=\"managua\")\nplt.colorbar(cb)\nplt.show()\n</code></pre> <pre><code>import jax.scipy.sparse.linalg as jsl\n\n\ndef projected_gauss_newton(\n    F,                  # function F(alpha) -&gt; residual vector (jax array)\n    alpha0,             # initial guess (full-sized vector)\n    lb,                 # lower bound (full-sized vector)\n    ub,                 # upper bound (full-sized vector)\n    max_iter=200,\n    tol=1e-10,\n    solver_tol=1e-8,    # Tolerance for the CG solver\n    solver_maxiter=None # Max iterations for the CG solver\n):\n    \"\"\"\n    Solve F(alpha) = 0 subject to lb &lt;= alpha &lt;= ub using a\n    projected Gauss-Newton method (matching PETSc's KSP 'cg').\n\n    This solves the normal equations (J^T J) * delta = -J^T F\n    in the projected free space.\n    \"\"\"\n\n    if solver_maxiter is None:\n        solver_maxiter = alpha0.size\n\n    # Jacobian-vector product: Jv(v) = J(alpha) @ v\n    def Jv_full(v, alpha):\n        return jax.jvp(F, (alpha,), (v,))[1]\n\n    # Vector-Jacobian product (transpose): vJ(v) = v^T @ J(alpha)\n    def vJ_full(v, alpha):\n        # jax.vjp returns (primals_out, vjp_fun)\n        _, vjp_fun = jax.vjp(F, alpha)\n        # vjp_fun(v) returns a tuple of gradients; we want the one for alpha\n        return vjp_fun(v)[0]\n\n    alpha = alpha0\n\n    for it in range(max_iter):\n        res = F(alpha)\n        fnorm = jnp.linalg.norm(res)\n\n        print(f\"Iter {it}, ||F||={fnorm}\")\n\n        if fnorm &lt; tol:\n            return alpha\n\n        # Identify active set\n        eps_proj = 1e-12\n        at_lb = (alpha &lt;= lb + eps_proj)\n        at_ub = (alpha &gt;= ub - eps_proj)\n        active = at_lb | at_ub\n\n        n_free = alpha.size - int(jnp.sum(active))\n        if n_free == 0:\n            print(\"All variables are active; no further progress can be made.\")\n            return alpha\n\n        # --- Define the full-space projected Gauss-Newton operator ---\n        # This operator A(v) computes (P_F @ J^T @ J @ P_F) @ v\n        def projected_JTJ_v(v):\n            # 1. Project input: v_in = P_F @ v\n            v_in = jnp.where(active, 0.0, v)\n\n            # 2. Apply J: Jv = J @ v_in\n            Jv = Jv_full(v_in, alpha)\n\n            # 3. Apply J^T: JTJv = J^T @ Jv\n            # We don't need to project Jv because J^T will only\n            # produce output in the free-space anyway (conceptually).\n            JTJv = vJ_full(Jv, alpha)\n\n            # 4. Project output: v_out = P_F @ JTJv\n            v_out = jnp.where(active, 0.0, JTJv)\n\n            return v_out\n\n        # --- Define the full-space projected right-hand side ---\n        # This is b = -P_F @ (J^T F)\n        JT_F = vJ_full(res, alpha)\n        r_full = jnp.where(active, 0.0, -JT_F)\n\n        # --- Solve the (symmetric) projected system using CG ---\n        delta, exit_code = jsl.cg(\n            projected_JTJ_v, \n            r_full, \n            tol=solver_tol, \n            maxiter=solver_maxiter\n        )\n\n        if exit_code != 0:\n            print(f\"Warning: CG solver did not converge. Exit code: {exit_code}\")\n\n        # --- TODO: ADD A LINE SEARCH HERE ---\n\n        step = 1.0\n        fnorm_old_sq = fnorm**2\n        for _ in range(50): # Max 10 line search steps\n            alpha_new = jnp.clip(alpha + step * delta, lb, ub)\n            res_new = F(alpha_new)\n            fnorm_new_sq = jnp.linalg.norm(res_new)**2\n\n            # Armijo condition (sufficient decrease)\n            if fnorm_new_sq &lt; fnorm_old_sq: # (simplified version)\n                alpha = alpha_new\n                break\n\n            step /= 2.0 # Decrease step size\n        else:\n            # Line search failed\n            print(\"Line search failed to find a better point.\")\n            return alpha\n    raise RuntimeError(\"Projected Gauss-Newton failed to converge within max_iter\")\n</code></pre> <pre><code>def projected_levenberg_marquardt(\n    F,                  # function F(alpha) -&gt; residual vector (jax array)\n    alpha0,             # initial guess (full-sized vector)\n    lb,                 # lower bound (full-sized vector)\n    ub,                 # upper bound (full-sized vector)\n    max_iter=200,\n    tol=1e-10,\n    solver_tol=1e-8,    # Tolerance for the CG solver\n    solver_maxiter=None,\n    damping=1e-4        # Damping parameter (lambda)\n):\n    \"\"\"\n    Solve F(alpha) = 0 subject to lb &lt;= alpha &lt;= ub using a\n    projected Levenberg-Marquardt method.\n\n    This solves the damped normal equations\n    (J^T J + damping*I) * delta = -J^T F\n    in the projected free space.\n    \"\"\"\n\n    if solver_maxiter is None:\n        solver_maxiter = alpha0.size\n\n    # Jacobian-vector product: Jv(v) = J(alpha) @ v\n    def Jv_full(v, alpha):\n        return jax.jvp(F, (alpha,), (v,))[1]\n\n    # Vector-Jacobian product (transpose): vJ(v) = v^T @ J(alpha)\n    def vJ_full(v, alpha):\n        _, vjp_fun = jax.vjp(F, alpha)\n        return vjp_fun(v)[0]\n\n    alpha = alpha0\n\n    for it in range(max_iter):\n        res = F(alpha)\n        fnorm = jnp.linalg.norm(res)\n\n        print(f\"Iter {it}, ||F||={fnorm}\")\n\n        if fnorm &lt; tol:\n            return alpha\n\n        # Identify active set\n        eps_proj = 1e-12\n        at_lb = (alpha &lt;= lb + eps_proj)\n        at_ub = (alpha &gt;= ub - eps_proj)\n        active = at_lb | at_ub\n\n        n_free = alpha.size - int(jnp.sum(active))\n        if n_free == 0:\n            print(\"All variables are active; no further progress can be made.\")\n            return alpha\n\n        # --- Define the full-space projected Levenberg-Marquardt operator ---\n        # This operator A(v) computes (P_F @ J^T @ J @ P_F + damping * P_F) @ v\n        def projected_LM_v(v):\n            # 1. Project input: v_in = P_F @ v\n            v_in = jnp.where(active, 0.0, v)\n\n            # 2. Apply J: Jv = J @ v_in\n            Jv = Jv_full(v_in, alpha)\n\n            # 3. Apply J^T: JTJv = J^T @ Jv\n            JTJv = vJ_full(Jv, alpha)\n\n            # 4. Project output and add damping term\n            # v_out = (P_F @ JTJv) + (damping * v_in)\n            v_out_jtj = jnp.where(active, 0.0, JTJv)\n            v_out = v_out_jtj + damping * v_in\n\n            return v_out\n\n        # --- Define the full-space projected right-hand side ---\n        # This is b = -P_F @ (J^T F)\n        JT_F = vJ_full(res, alpha)\n        r_full = jnp.where(active, 0.0, -JT_F)\n\n        # --- Solve the (damped, symmetric) projected system using CG ---\n        delta, exit_code = jsl.cg(\n            projected_LM_v, \n            r_full, \n            tol=solver_tol, \n            maxiter=solver_maxiter\n        )\n\n        if exit_code != 0:\n            print(f\"Warning: CG solver did not converge. Exit code: {exit_code}\")\n\n        # --- Simple Backtracking Line Search ---\n        step = 1.0\n        fnorm_old_sq = fnorm**2\n\n        # We need a JAX-compatible loop for the line search \n        # to work inside a @jit. Using lax.fori_loop.\n        # This is more complex, but a simple python loop is fine if not jitting.\n\n        # --- Python-based Line Search (simple, but not JIT-compatible) ---\n        alpha_new = alpha # In case line search fails\n        for _ in range(10): # Max 10 line search steps\n            alpha_test = jnp.clip(alpha + step * delta, lb, ub)\n            res_new = F(alpha_test)\n            fnorm_new_sq = jnp.linalg.norm(res_new)**2\n\n            # Simple decrease condition\n            if fnorm_new_sq &lt; fnorm_old_sq:\n                alpha_new = alpha_test\n                break # Found a good step\n\n            step /= 2.0 # Decrease step size\n        else:\n            # Line search failed to find a better point\n            print(\"Line search failed; stopping.\")\n            return alpha\n\n        alpha = alpha_new\n\n\n    raise RuntimeError(\"Levenberg-Marquardt failed to converge within max_iter\")\n</code></pre> <pre><code>alpha_new = projected_levenberg_marquardt(\n    F=F,\n    alpha0= (alpha0.reshape(-1) + 1)/2,\n    lb=alpha0.reshape(-1),\n    ub=jnp.ones_like(alpha0).reshape(-1),\n    max_iter=50,\n    tol=1e-6,\n    damping=1e-6\n)\n</code></pre> <pre><code>Iter 0, ||F||=8.576612912588672\nWarning: CG solver did not converge. Exit code: None\nIter 1, ||F||=7.440102668608955\nWarning: CG solver did not converge. Exit code: None\nIter 2, ||F||=7.426486839017538\nWarning: CG solver did not converge. Exit code: None\nIter 3, ||F||=7.4264868383189215\nWarning: CG solver did not converge. Exit code: None\nLine search failed; stopping.\n</code></pre> <pre><code>plt.imshow(alpha_new.reshape((N, N)), cmap=\"managua\")\nplt.colorbar()\nplt.show()\n</code></pre> <pre><code>class FractureProblem:\n\n    def __init__(self, epsilon, N):\n        self.epsilon = epsilon\n        self.N = N\n        self.compute =eqx.Partial(fracture_strong_form, epsilon=epsilon)\n        #self.jac = partial(dFdalpha, epsilon=epsilon)\n\n    def function(self, snes, X, F):\n        x = jnp.array(X.getArray())\n        f = self.compute(x)\n        F[:] = f \n\n\n# for the case when we need to pass jacobian as well to petsc solver\ndFdalpha = jax.jacfwd(fracture_strong_form)\n</code></pre> <pre><code>imshow(return_val=False)(lambda x :x)(strain_energy_plus)\n</code></pre> <pre><code>jax.__version__\n</code></pre> <pre><code>'0.4.30'\n</code></pre> <pre><code># register the function in charge of\n# computing the nonlinear residual\n\nfrac = FractureProblem(eps, N)\n\nsnes = PETSc.SNES().create(comm=PETSc.COMM_SELF)\nf = PETSc.Vec().createSeq(N * N)\nsnes.setFunction(frac.function, f)\n\nalpha_lb = f.duplicate()\nalpha_ub = f.duplicate()\nalpha_lb.setArray(structure.reshape(-1))\nalpha_ub.set(1)\n\nsnes.setUseMF(True)\nsnes.getKSP().setType('cg')\n\nsnes.setType(\"vinewtonrsls\")\nsnes.setVariableBounds(alpha_lb, alpha_ub)\nsnes.setTolerances(atol=1e-8, rtol=1e-10)\nsnes.setConvergenceHistory()\nsnes.setConvergedReason(reason=PETSc.SNES.ConvergedReason.CONVERGED_FNORM_ABS)\nsnes.getKSP().setConvergedReason(reason=PETSc.KSP.ConvergedReason.CONVERGED_ATOL)\nsnes.setMonitor(lambda _, it, residual: print(it, residual))\n\n\nb, alpha = None, f.duplicate()\nalpha.setArray(structure.reshape(-1))  # zero inital guess\n\nsnes.solve(b, alpha)\nprint(PETSc.SNES.ConvergedReason.CONVERGED_FNORM_ABS == snes.getConvergedReason())\nprint(snes.getKSP().getConvergedReason())\n\n\nsnes.view()\n_ = snes.destroy()\n</code></pre> <pre><code>0 9.438962786807954\n1 2.6469312602578805\n2 0.8851912804187733\n3 0.04188464560249006\n4 0.005969123284172579\n5 4.8852971304445077e-08\n6 2.1318936773795206e-13\nTrue\n2\nSNES Object: 1 MPI process\n  type: vinewtonrsls\n  maximum iterations=50, maximum function evaluations=10000\n  tolerances: relative=1e-10, absolute=1e-08, solution=1e-08\n  total number of linear solver iterations=129\n  total number of function evaluations=142\n  norm schedule ALWAYS\n  SNESLineSearch Object: 1 MPI process\n    type: bt\n      interpolation: cubic\n      alpha=0.000000e+00\n    maxstep=1.000000e+08, minlambda=1.000000e-12\n    tolerances: relative=1.000000e-08, absolute=1.000000e-15, lambda=1.000000e-08\n    maximum iterations=40\n  KSP Object: 1 MPI process\n    type: cg\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=1e-05, absolute=1e-50, divergence=10000.\n    left preconditioning\n    using PRECONDITIONED norm type for convergence test\n  PC Object: 1 MPI process\n    type: none\n    linear system matrix = precond matrix:\n    Mat Object: 1 MPI process\n      type: submatrix\n      rows=240, cols=240\n</code></pre> <pre><code>imshow(cmap=cmc.managua, return_val=False)(lambda x: x)(alpha.array.reshape((N, N)))\n</code></pre> <pre><code>plot()(lambda x: x)(\n    (np.linspace(0, length, num=N), alpha.array.reshape((N, N))[:, int(N / 2)])\n)\n</code></pre> <pre><code>alpha_prev = structure\napplied_strains = np.diff(np.linspace(0, 2e-1, num=200))\neps = jnp.zeros([ndim, ndim, N, N])\ndeps = jnp.zeros([ndim, ndim, N, N])\n\nfor inc, deps_avg in enumerate(applied_strains):\n\n    deps = deps.at[0, 0].set(deps_avg)\n\n    # initial residual: distribute \"DE\" over grid using \"K4\"\n    b = -G_K_deps(deps, alpha_prev)\n    eps = jax.lax.add(eps, deps)\n    _G_K_deps = jax.jit(partial(G_K_deps, alpha=alpha_prev))\n    state = (deps, b, eps)\n\n    final_state = newton_krylov_solver(\n        state, tol=1e-8, A=_G_K_deps, max_iter=30, krylov_solver=conjugate_gradient\n    )\n\n    eps = final_state[2]\n\n    frac = FractureProblem(eps, N)\n\n    snes = PETSc.SNES().create(comm=PETSc.COMM_SELF)\n    f = PETSc.Vec().createSeq(N * N)\n    snes.setFunction(frac.function, f)\n\n    alpha_lb = f.duplicate()\n    alpha_ub = f.duplicate()\n    alpha_lb.setArray(alpha_prev.reshape(-1))\n    alpha_ub.set(1)\n\n    snes.setUseMF(True)\n    snes.getKSP().setType(\"cg\")\n\n    snes.setType(\"vinewtonrsls\")\n    snes.setVariableBounds(alpha_lb, alpha_ub)\n    snes.setTolerances(atol=1e-8, rtol=1e-10)\n    snes.setConvergenceHistory()\n    snes.setConvergedReason(reason=PETSc.SNES.ConvergedReason.CONVERGED_FNORM_ABS)\n    snes.getKSP().setConvergedReason(reason=PETSc.KSP.ConvergedReason.CONVERGED_ATOL)\n\n    b, alpha = None, f.duplicate()\n    alpha.setArray(structure.reshape(-1))  # zero inital guess\n\n    snes.solve(b, alpha)\n    print(PETSc.SNES.ConvergedReason.CONVERGED_FNORM_ABS == snes.getConvergedReason())\n    print(snes.getKSP().getConvergedReason())\n\n    alpha_prev = alpha.getArray().reshape((N, N))\n\n    _ = snes.destroy()\n</code></pre> <pre><code>Converged, Residual value : 7.93203230207842e-09\nTrue\n2\nConverged, Residual value : 8.278249052263994e-09\nTrue\n2\nConverged, Residual value : 7.584749293043743e-09\nTrue\n2\nConverged, Residual value : 6.892623410986616e-09\nTrue\n2\nConverged, Residual value : 9.697588186967834e-09\nTrue\n2\nConverged, Residual value : 9.705894906820199e-09\nTrue\n2\nConverged, Residual value : 9.536827352368334e-09\nTrue\n2\nConverged, Residual value : 9.721977941727304e-09\nTrue\n2\nConverged, Residual value : 9.5688158401759e-09\nTrue\n2\nConverged, Residual value : 9.261714453957313e-09\nTrue\n2\nConverged, Residual value : 9.664320310276714e-09\nTrue\n2\nConverged, Residual value : 8.717934379950834e-09\nTrue\n2\nConverged, Residual value : 8.515044484572433e-09\nTrue\n2\nConverged, Residual value : 8.673053576376339e-09\nTrue\n2\nConverged, Residual value : 9.564906715642803e-09\nTrue\n2\nConverged, Residual value : 9.551721229359999e-09\nTrue\n2\nConverged, Residual value : 8.871350550515968e-09\nTrue\n2\nConverged, Residual value : 8.798211918044168e-09\nTrue\n2\nConverged, Residual value : 8.751578114460782e-09\nTrue\n2\nConverged, Residual value : 8.749529482260385e-09\nTrue\n2\nConverged, Residual value : 8.862257557114492e-09\nTrue\n2\nConverged, Residual value : 9.047540710717199e-09\nTrue\n2\nConverged, Residual value : 9.269417469215378e-09\nTrue\n2\nConverged, Residual value : 9.509987716151102e-09\nTrue\n2\nConverged, Residual value : 9.731335678634471e-09\nTrue\n2\nConverged, Residual value : 9.88562535051767e-09\nTrue\n2\nConverged, Residual value : 9.939967964056066e-09\nTrue\n2\nConverged, Residual value : 9.968421991717961e-09\nTrue\n2\nConverged, Residual value : 9.452648338972572e-09\nTrue\n2\nConverged, Residual value : 9.559101771369614e-09\nTrue\n2\nConverged, Residual value : 9.673807423873853e-09\nTrue\n2\nConverged, Residual value : 9.795464813780874e-09\nTrue\n2\nConverged, Residual value : 9.943086454938821e-09\nTrue\n2\nConverged, Residual value : 4.791674845389095e-09\nTrue\n2\nConverged, Residual value : 4.906050755547834e-09\nTrue\n2\nConverged, Residual value : 5.0018653495566436e-09\nTrue\n2\nConverged, Residual value : 7.3931265567697e-09\nTrue\n2\nConverged, Residual value : 7.567597488803572e-09\nTrue\n2\nConverged, Residual value : 7.761436122002211e-09\nTrue\n2\nConverged, Residual value : 8.017084994167426e-09\nTrue\n2\nConverged, Residual value : 8.267414627513927e-09\nTrue\n2\nConverged, Residual value : 8.54301518061114e-09\nTrue\n2\nConverged, Residual value : 8.817275819247072e-09\nTrue\n2\nConverged, Residual value : 9.126027633086242e-09\nTrue\n2\nConverged, Residual value : 9.399479812375493e-09\nTrue\n2\nConverged, Residual value : 9.64293191713525e-09\nTrue\n2\nConverged, Residual value : 8.94508909214961e-09\nTrue\n2\nConverged, Residual value : 9.433402656002151e-09\nTrue\n2\nConverged, Residual value : 9.868681583264604e-09\nTrue\n2\n</code></pre> <pre><code>The Kernel crashed while executing code in the current cell or a previous cell. \n\nPlease review the code in the cell(s) to identify a possible cause of the failure. \n\nClick &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. \n\nView Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.\n</code></pre> <pre><code>Canceled future for execute_request message before replies were done\n</code></pre> <pre><code>Canceled future for execute_request message before replies were done. \n\nView Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.\n</code></pre> <pre><code>imshow(cmap=cmc.roma, return_val=False)(lambda x: x)(alpha_prev)\n</code></pre> <pre><code>---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 imshow(cmap=cmc.roma, return_val=False)(lambda x: x)(alpha_prev)\n\nNameError: name 'imshow' is not defined\n</code></pre> <pre><code>sig00, eps00 = get_stress_strains(final_state, alpha_prev)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/phasefield_localization_1D/","title":"Phasefield Localization in 1D","text":"<p>In this tutorial, we will demonstrate how to simulate phasefield localization in a one-dimensional bar using spectral methods. We will utilize the <code>xpektra</code> library for spectral computations and <code>jax</code> for automatic differentiation. The goal is to minimize the energy functional associated with the phasefield variable, which represents the damage state of the material.</p> <p>This tutorial shows how to use the <code>xpektra</code> library for how to solve a minimization problem using spectral methods in 1D and pair it with <code>jax</code> for automatic differentiation to compute gradients and Hessians.</p> <pre><code>import jax\njax.config.update(\"jax_enable_x64\", True)\njax.config.update(\"jax_platforms\", \"cpu\")\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\n\nimport jax.numpy as jnp\nimport numpy as np\n\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code>from xpektra import SpectralSpace\nfrom xpektra.transform import FFTTransform\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.scheme import FourierScheme\n</code></pre> <p>We start with defining the 1D localization problem using phase field modeling. We consider a bar of length <code>length</code> discretized into <code>N</code> points. The phase field variable <code>alpha</code> represents the damage state of the material, where <code>alpha = 0</code> indicates undamaged material and <code>alpha = 1</code> indicates fully damaged material.</p> <p>The objective function to be minimized is as follows:</p> \\[ \\textsf{min} \\int_\\Omega  \\Big( \\alpha + \\ell_0^2 \\nabla   \\alpha \\cdot{} \\nabla \\alpha \\Big) \\textsf{d}\\Omega \\] \\[ \\textsf{such that} ~ 0 &lt;  \\alpha(x) &lt; 1 \\] <pre><code>N = 69\nndim = 1\nlength = 10\ndx = length / N\n\nell = 1.0\n</code></pre> <p>From <code>xpektra</code>, we import necessary modules to set up the spectral space, transformations, and operators needed for our computations. To handle the gradients and Laplacians in the spectral domain, we utilize Fourier transforms.</p> <pre><code>fft_transform = FFTTransform(ndim)\nspace = SpectralSpace(shape=(N,), lengths=(length,), transform=fft_transform)\nscheme = FourierScheme(space=space)\nop = SpectralOperator(scheme=scheme, space=space)\n</code></pre> <p>Now we can define our objective function and compute its Jacobian and Hessian using JAX's automatic differentiation capabilities.</p> <pre><code>@jax.jit\ndef f(alpha):\n    grad_alpha = op.grad(alpha)\n    energy = alpha + ell * ell * grad_alpha * grad_alpha\n    return energy.sum() * dx ** ndim\n\njacobian = jax.jacrev(f)\nhessian= jax.jacfwd(jacobian)\n</code></pre> <p>We start by imposing a seed crack at the center of the bar to initiate the localization process.</p> <pre><code>alpha0 = 1.\nalpha = jnp.zeros(N)\nalpha = alpha.at[int(N/2)].set(alpha0)\n</code></pre> <p>We perform the constrained  minimization using the <code>scipy.optimize.minimize</code> function with the 'SLSQP' method, which is suitable for handling bound constraints on the phase field variable <code>alpha</code>. The optimization iteratively updates <code>alpha</code> to minimize the objective function while ensuring that it remains within the specified bounds.</p> <pre><code>from scipy.optimize import minimize, Bounds\n</code></pre> <pre><code>lower_bounds = jnp.zeros_like(alpha)\nupper_bounds = jnp.ones_like(alpha)\n\nbnds = Bounds(lb=lower_bounds, ub=upper_bounds)\ncons = ({'type': 'eq', 'fun': lambda x:  x[int(N/2)] - alpha0})\nres = minimize(f, alpha, method='SLSQP', jac=jacobian,  bounds=bnds, constraints=cons)\n</code></pre> <p>Finally, we visualize the resulting phase field distribution along the bar, which illustrates the localization of damage initiated from the seed crack. The plot shows how <code>alpha</code> varies from 0 (undamaged) to 1 (fully damaged) along the length of the bar.</p> <pre><code>def ppos(x):\n    return np.maximum(x, np.zeros_like(x))\n\nx = np.linspace(-length/2, length/2, num=N)\nalpha_an = (ppos(np.sqrt(alpha0) - np.abs(x / 2 / ell))) ** 2\n\nplt.figure(figsize=(3, 3))\nplt.plot(x, alpha_an, 'o-')\nplt.plot(x, res.x, 'o-')\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/st_venant_kirchhoff/","title":"St venant kirchhoff","text":"<p>In this tutorial, we solve a nonlinear elasticity problem using the Fourier-Galerkin method implemented in the <code>xpektra</code> library. We use hyperelastic material models to define the stress-strain relationship. The problem is solved using a Newton-Krylov solver with a conjugate gradient method as the linear solver.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\n\nimport jax.numpy as jnp\nfrom jax import Array\n\nimport numpy as np\n</code></pre> <pre><code>from xpektra import SpectralSpace, make_field\nfrom xpektra.transform import FFTTransform\nfrom xpektra.scheme import RotatedDifference\nfrom xpektra.spectral_operator import SpectralOperator\nfrom xpektra.projection_operator import GalerkinProjection\n\nfrom xpektra.solvers.nonlinear import (  # noqa: E402\n    NewtonSolver,\n    conjugate_gradient,\n)\n\nfrom functools import partial\nimport equinox as eqx\nimport matplotlib.pyplot as plt \nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n</code></pre>"},{"location":"examples/st_venant_kirchhoff/#constructing-a-dual-phase-rve","title":"Constructing a dual phase RVE","text":"<p>We define a dual-phase RVE with a square inclusion in a square matrix. The inclusion has different material properties than the matrix.</p> <pre><code>ndim = 2\nN = 199\nlength = 1.0\n\nr = int(N / 3)\n\nstructure = np.zeros((N, N))\nstructure[:r, -r:] +=  np.ones((r, r))\n\nfig = plt.figure(figsize=(4, 4))\nax = plt.axes()\ncb = plt.imshow(structure, origin=\"lower\", cmap=\"viridis\")\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb, cax=cax, label=r\"Phase\", orientation=\"horizontal\", location=\"top\"\n)\n\nplt.show()\n</code></pre> <p></p> <p>The square inclusion is stiffer than the matrix. The material properties are defined using the St. Venant-Kirchhoff hyperelastic model.</p> <pre><code>E1 = 0.57\nE2 = 5.7   \nnu1 = 0.386\nnu2 = 0.386\n\nlambda1 = E1 * nu1 / ((1 + nu1) * (1 - 2 * nu1))\nmu1 = E1 / (2 * (1 + nu1))\n\nlambda2 = E2 * nu2 / ((1 + nu2) * (1 - 2 * nu2))\nmu2 = E2 / (2 * (1 + nu2))\n\n\nlambdas = lambda1 * (1.0 - structure) + lambda2 * structure\nmus = mu1 * (1.0 - structure) + mu2 * structure\n</code></pre>"},{"location":"examples/st_venant_kirchhoff/#defining-the-operators","title":"Defining the Operators","text":"<p>In order to define the Fourier-Galerkin operator, we first define the spectral space, the transform operators, and the spectral operators. We use the <code>SpectralSpace</code> class to define the spectral space, the <code>Fourier</code> class to define the FFT and IFFT operators, and the <code>RotatedDifference</code> class to define the spatial operators.</p> <p>Finally we define the Spectral Operators using the <code>SpectralOperator</code> class which takes the spectral space and the spatial operators as input.</p> <pre><code>fft_transform = FFTTransform(dim=ndim)\nspace = SpectralSpace(\n    lengths=(length,) * ndim, shape=structure.shape, transform=fft_transform\n)\nrotated_scheme = RotatedDifference(space=space)\n\nop = SpectralOperator(\n    scheme=rotated_scheme,\n    space=space,\n)\n\nGhat = GalerkinProjection(scheme=rotated_scheme)\ndofs_shape = make_field(dim=ndim, shape=structure.shape, rank=2).shape\n</code></pre> <p>The strain energy density function for the St. Venant-Kirchhoff model is given by:</p> \\[\\Psi = \\frac{1}{2} \\lambda (\\text{tr}(E))^2 + \\mu \\text{tr}(E^2)\\] <p>where \\(E\\) is the Green-Lagrange strain tensor, and \\(\\lambda\\) and \\(\\mu\\) are the Lam\u00e9 parameters. The Green-Lagrange strain tensor is defined as:</p> \\[E = \\frac{1}{2} (F^T F - I)\\] <p>where \\(F\\) is the deformation gradient tensor and \\(I\\) is the identity tensor.</p> <p>The first Piola-Kirchhoff stress tensor \\(P\\) is derived from the strain energy density function as: </p> \\[P = \\frac{\\partial \\Psi}{\\partial F}\\] <pre><code>i = jnp.eye(ndim)\nI = make_field(dim=ndim, shape=structure.shape, rank=2) + i\n\n@eqx.filter_jit\ndef green_lagrange_strain(F: Array) -&gt; Array:\n    return 0.5 * (op.dot(op.trans(F), F) - I)\n\n\n@eqx.filter_jit\ndef strain_energy(F_flat: Array) -&gt; float:\n    F = F_flat.reshape(dofs_shape)\n    E = green_lagrange_strain(F)\n    E = 0.5 * (E + op.trans(E))\n    energy = 0.5 * jnp.multiply(lambdas, op.trace(E) ** 2) + jnp.multiply(\n        mus, op.trace(op.dot(E, E))\n    )\n    return energy.sum()\n\n\ncompute_stress = jax.jacrev(strain_energy)\n</code></pre>"},{"location":"examples/st_venant_kirchhoff/#defining-the-residual-and-jacobian-functions","title":"Defining the Residual and Jacobian Functions","text":"<p>We now define the residual function and the Jacobian function for the Newton solver. The residual function computes the residual of the problem based on the given macro strain. It takes only the flattened vector of fluctuation strain and a macro strain. The Jacobian function represents the Jacobian-vector product.</p> <p>The total deformation gradient is given as</p> \\[F = \\tilde{F} + F_\\text{macro}^{i}  \\] <p>where \\(\\tilde{F}\\) is the fluctuation strain and \\(\\mathbf{F}_\\text{macro}^{i}\\) is the applied macro strain at iteration \\(i\\).</p> <p>The residual is given as</p> \\[R(\\tilde{F}, F_\\text{macro}) = \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\mathbf{\\sigma}(\\tilde{F} + F_\\text{macro}^{i})) \\right) \\] <p>where \\(\\mathbb{G}\\) is the Fourier-Galerkin operator defined earlier, \\(\\mathcal{F}\\) and \\(\\mathcal{F}^{-1}\\) are the FFT and IFFT operators respectively, and \\(\\mathbf{\\sigma}\\) is the stress tensor computed from the strain energy function defined earlier.</p> <p>We can define the residual at \\(\\tilde{F} + \\Delta \\tilde{F}\\) as</p> \\[R(\\tilde{\\mathbf{F}} + \\Delta \\tilde{\\mathbf{F}}, F_\\text{macro}) = \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\mathbf{\\sigma}(\\tilde{F} + \\Delta \\tilde{\\mathbf{F}} + F_\\text{macro}^{i})) \\right) \\] <p>USing the Taylor expansion, we can write</p> \\[R(\\tilde{\\mathbf{F}} + \\Delta \\tilde{\\mathbf{F}}, F_\\text{macro}) \\approx R(\\tilde{\\mathbf{F}}, F_\\text{macro}) + \\frac{\\partial R}{\\partial \\tilde{\\mathbf{F}}} \\Delta \\tilde{\\mathbf{F}} \\] <p>Below we define the residual function and the Jacobian function using the above equations.</p> <p>We use <code>op.forward</code> and <code>op.inverse</code> methods to apply the FFT and IFFT operators respectively.</p> <p>We compute the tangents at \\(\\Delta \\tilde{F}\\) as Jacobian-vector products i.e.,</p> \\[\\frac{\\partial R}{\\partial \\tilde{F}} \\Delta \\tilde{F} = \\mathcal{F}^{-1} \\left( \\mathbb{G}:\\mathcal{F}(\\sigma(\\Delta \\tilde{F})) \\right) \\] <pre><code>@eqx.filter_jit\ndef residual_fn(eps_fluc_flat: Array, macro_strain: float) -&gt; Array:\n    \"\"\"\n    A function that computes the residual of the problem based on the given macro strain.\n    It takes only the flattened vector of fluctuation strain and a macro strain.\n\n    Args:\n        eps_fluc_flat: Flattened vector of fluctuation strain.\n        macro_strain: Macro strain.\n\n    Returns:\n        Residual field.\n    \"\"\"\n\n    eps_fluc = eps_fluc_flat.reshape(dofs_shape)\n    eps_macro = jnp.zeros(dofs_shape)\n    eps_macro = eps_macro.at[:, :, 0, 0].set(macro_strain)\n    eps_macro = eps_macro.at[:, :, 1, 1].set(macro_strain)\n    eps_total = eps_fluc + eps_macro\n    eps_flat = eps_total.reshape(-1)\n    sigma = compute_stress(eps_flat)\n    residual_field = op.inverse(Ghat.project(op.forward(sigma.reshape(dofs_shape))))\n    return jnp.real(residual_field).reshape(-1)\n\n@eqx.filter_jit\ndef jacobian_fn(deps_fluc_flat: Array, eps_fluc_flat: Array) -&gt; Array:\n\n    deps_flat = deps_fluc_flat.reshape(-1)\n    eps_fluc = eps_fluc_flat.reshape(-1)\n    dsigma = jax.jvp(compute_stress, (eps_fluc,), (deps_flat,))[1]\n    jvp_field = op.inverse(\n        Ghat.project(op.forward(dsigma.reshape(dofs_shape)))\n    )\n    return jnp.real(jvp_field).reshape(-1)\n</code></pre> <p>We definre the Newton-Krylov solver using the <code>NewtonKrylovSolver</code> class. We set the maximum number of iterations and the tolerance for convergence. We also define the linear solver to be used within the Newton-Krylov solver, which is the conjugate gradient method in this case.</p> <pre><code>solver = NewtonSolver(\n    tol=1e-8,\n    max_iter=20,\n    krylov_solver=conjugate_gradient,\n    krylov_tol=1e-8,\n    krylov_max_iter=20,\n)\n</code></pre> <pre><code>applied_strains = jnp.linspace(0.0, 0.01, num=6)\nF_fluc_init = jnp.array(make_field(dim=ndim, shape=structure.shape, rank=2))\nF_fluc_init = F_fluc_init.at[:, :, 0, 0].set(1.0)\nF_fluc_init = F_fluc_init.at[:, :, 1, 1].set(1.0)\n\n\nfor inc, macro_defo in enumerate(applied_strains):\n    print(f\"Increment {inc+1}/{len(applied_strains)}: Applied strain = {macro_defo}\")\n    # solving for elasticity\n    residual = jax.jit(partial(residual_fn, macro_strain=macro_defo))\n    jacobian = jax.jit(partial(jacobian_fn, eps_fluc_flat=F_fluc_init.reshape(-1),))# gradient=residual))\n\n    b = -residual(F_fluc_init.reshape(-1))\n\n    dF_fluc = solver.solve(\n        x=F_fluc_init.reshape(-1),\n        b=b,\n        f=residual,\n        jac=jacobian,\n    )\n\n    F_fluc = F_fluc_init + dF_fluc.reshape(dofs_shape) - jnp.eye(ndim)[None, None, :, :]  # remove identity part\n    F_fluc_init = F_fluc\n\n    F = F_fluc + jnp.eye(ndim)[None, None, :, :] * ( macro_defo)\n\nP = compute_stress(F.reshape(-1)).reshape(dofs_shape)\n</code></pre> <pre><code>Increment 1/6: Applied strain = 0.0\nConverged, Residual value : 0.0\nIncrement 2/6: Applied strain = 0.002\nConverged, Residual value : 8.947782934727865e-09\nIncrement 3/6: Applied strain = 0.004\nConverged, Residual value : 9.26545625883322e-09\nIncrement 4/6: Applied strain = 0.006\nConverged, Residual value : 7.997564774594936e-09\nIncrement 5/6: Applied strain = 0.008\nConverged, Residual value : 3.2928063710209945e-09\nIncrement 6/6: Applied strain = 0.01\nConverged, Residual value : 7.866176824734989e-09\n</code></pre> <pre><code>from mpl_toolkits.axes_grid1 import make_axes_locatable\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3), layout=\"constrained\")\n\ncb = ax1.imshow(F.at[:, :, 1, 1].get(), cmap=\"managua\", origin=\"lower\")\ndivider = make_axes_locatable(ax1)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb, cax=cax, label=r\"$F_{yy}$\", orientation=\"horizontal\", location=\"top\"\n)\n\n\ncb = ax2.imshow(P.at[:, :, 0, 1].get(), cmap=\"Spectral\", origin=\"lower\")\ndivider = make_axes_locatable(ax2)\ncax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\nfig.colorbar(\n    cb, cax=cax, label=r\"$P_{xy}$\", orientation=\"horizontal\", location=\"top\"\n)\n\n\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/topology_optimization/","title":"Topology optimization","text":"<pre><code>import jax\n\njax.config.update(\n    \"jax_compilation_cache_dir\", \"/cluster/scratch/mpundir/jax-cache-notebook\"\n)\nimport jax.numpy as jnp\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_platforms\", \"cpu\")\nimport numpy as np\n\nimport functools\nfrom jax.typing import ArrayLike\nfrom jax import Array\n\nfrom tqdm.notebook import tqdm\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom skimage.morphology import disk, rectangle\nimport itertools\nfrom matplotlib.gridspec import GridSpec\n</code></pre> <pre><code>import sys\n\nsys.path.append(\"../fft_helpers/\")\n\nfrom projection_operators import compute_Ghat_4_2\nimport tensor_operators as tensor\nfrom custom_solvers import conjugate_gradient\n\nsys.path.append(\"../plot_helpers/\")\nplt.style.use([\"../plot_helpers/prl_paper.mplstyle\"])\nfrom plot_helper_for_paper import set_size, plot_imshow, plot_contourf\n</code></pre> \\[\\begin{align*}     \\underset{\\rho}{ \\text{maximize}} &amp;:~ f(\\rho, \\boldsymbol{F}) \\\\      \\text{s.t} &amp;: ~\\mathcal{F}^{-1} \\{ \\mathcal{F} \\{  \\mathbb{G} \\} :   \\mathcal{F} \\{ \\sigma \\} \\}  = 0~, \\\\                 &amp; : ~\\int \\rho(\\boldsymbol{x}) d\\Omega / \\int d\\Omega = \\vartheta~,  \\\\                 &amp; :~ 0 \\leq \\rho(\\boldsymbol{x}) \\leq 1 , \\forall \\boldsymbol{x} \\in \\Omega   \\end{align*}\\] <p>The implementation of <code>Optimality criteria</code> and <code>sensitivity filter</code> has been taken from the work of Chandrasekhar et al http://arxiv.org/abs/2104.01965</p> <pre><code># %% Filter\n# Reference: http://arxiv.org/abs/2104.01965\ndef compute_filter(rmin):\n    H = np.zeros((N * N, N * N))\n\n    for i1 in range(N):\n        for j1 in range(N):\n            e1 = (i1) * N + j1\n            imin = max(i1 - (np.ceil(rmin) - 1), 0.0)\n            imax = min(i1 + (np.ceil(rmin)), N)\n            for i2 in range(int(imin), int(imax)):\n                jmin = max(j1 - (np.ceil(rmin) - 1), 0.0)\n                jmax = min(j1 + (np.ceil(rmin)), N)\n                for j2 in range(int(jmin), int(jmax)):\n                    e2 = i2 * N + j2\n                    H[e1, e2] = max(\n                        0.0, rmin - np.sqrt((i1 - i2) ** 2 + (j1 - j2) ** 2)\n                    )\n\n    Hs = np.sum(H, 1)\n    return H, Hs\n</code></pre> <pre><code>#length = 1.0\nN = 99\n\n# material parameters\nelastic_modulus = {\"max\": 1.0, \"min\": 1e-3}  # N/mm2\npoisson_modulus = 0.3\npenalty = 5.0\n\nvf = 0.3\n\ndx = dy = 1.0\nlength = dx*N\n\nH, Hs = compute_filter(rmin=1.3)\nft = {\"type\": 2, \"H\": H, \"Hs\": Hs}\n\n\n\u03bc = elastic_modulus['max'] / (2 * (1 + poisson_modulus))\n\u03bb = poisson_modulus * elastic_modulus['max'] / ((1 + poisson_modulus) * (1 - 2 * poisson_modulus))\n\u03bb = 2*\u03bc*\u03bb/(\u03bb + 2*\u03bc) # for plane stress\nK = \u03bb + 2 * \u03bc / 2\nprint(\u03bc*K*vf/(2*\u03bc+2*K-(K+2*\u03bc)*vf))\n\nHmax = \u03bc*K/(K+2*\u03bc)\n</code></pre> <pre><code>0.0470219435736677\n</code></pre> <pre><code>\u03bc\n</code></pre> <pre><code>0.3846153846153846\n</code></pre> <pre><code>trial = vf/(Hmax+ \u03bc) + (1-vf)/Hmax\n</code></pre> <pre><code>1/trial - Hmax\n</code></pre> <pre><code>0.04702194357366771\n</code></pre> <pre><code>ndim = 2\n# identity tensor (single tensor)\ni = jnp.eye(ndim)\n\n# identity tensors (grid)\nI = jnp.einsum(\"ij,xy\", i, jnp.ones([N, N]))  # 2nd order Identity tensor\n\nI4 = jnp.einsum(\n    \"ijkl,xy-&gt;ijklxy\",\n    jnp.einsum(\"il,jk\", i, i),\n    jnp.ones(\n        [\n            N,\n        ]\n        * ndim\n    ),\n)\nI4rt = jnp.einsum(\n    \"ijkl,xy-&gt;ijklxy\",\n    jnp.einsum(\"ik,jl\", i, i),\n    jnp.ones(\n        [\n            N,\n        ]\n        * ndim\n    ),\n)\n\n\nI4s = (I4 + I4rt) / 2.0\nII = tensor.dyad22(I, I)\nI4d = I4s - II / 3.0\n</code></pre> <pre><code># (inverse) Fourier transform (for each tensor component in each direction)\n@jax.jit\ndef fft(x):\n    return jnp.fft.fftshift(jnp.fft.fftn(jnp.fft.ifftshift(x), [N, N]))\n\n\n@jax.jit\ndef ifft(x):\n    return jnp.fft.fftshift(jnp.fft.ifftn(jnp.fft.ifftshift(x), [N, N]))\n</code></pre> <pre><code>Ghat4_2 = compute_Ghat_4_2(NN=(N,) * ndim, operator=\"rotated\", length=length)\n</code></pre> <pre><code>@jax.jit\ndef param(rho):\n    rho = rho.reshape(N, N)\n    E = (\n        elastic_modulus[\"min\"]\n        + (elastic_modulus[\"max\"] - elastic_modulus[\"min\"]) * (rho + 0.01) ** penalty\n    )\n    return E\n</code></pre> <pre><code># --------------------------#\n# Reference: http://arxiv.org/abs/2104.01965\ndef get_initial_density(vf):\n    rho = vf * np.ones((N, N))\n    d = np.minimum(N, N) / 3.0\n    ctr = 0\n    for i in range(N):\n        for j in range(N):\n            r = np.sqrt((i - N / 2.0 - 0.5) ** 2 + (j - N / 2.0 - 0.5) ** 2)\n            if r &lt; d:\n                rho[j, i] = vf / 2.0\n            ctr += 1\n    rho = rho.reshape(-1)\n    return rho\n</code></pre> <pre><code># Reference: http://arxiv.org/abs/2104.01965\ndef apply_sensitivity_filter(ft, x, dc, dv):\n    if ft[\"type\"] == 1:\n        dc = np.matmul(ft[\"H\"], np.multiply(x, dc) / ft[\"Hs\"] / np.maximum(1e-3, x))\n    elif ft[\"type\"] == 2:\n        dc = np.matmul(ft[\"H\"], (dc / ft[\"Hs\"]))\n        dv = np.matmul(ft[\"H\"], (dv / ft[\"Hs\"]))\n    return dc, dv\n</code></pre> <pre><code># Reference: http://arxiv.org/abs/2104.01965\ndef oc(rho, dc, dv, ft, vf):\n    l1 = 0\n\n    l2 = 1e9\n    x = rho.copy()\n    move = 0.2\n    while l2 - l1 &gt; 1e-6:\n        lmid = 0.5 * (l2 + l1)\n        dr = np.abs(-dc / dv / lmid)\n\n        xnew = np.maximum(\n            0,\n            np.maximum(x - move, np.minimum(1, np.minimum(x + move, x * np.sqrt(dr)))),\n        )\n        if ft[\"type\"] == 1:\n            rho = xnew\n        elif ft[\"type\"] == 2:\n            rho = np.matmul(ft[\"H\"], xnew) / ft[\"Hs\"]\n        if np.mean(rho) &gt; vf:\n            l1 = lmid\n        else:\n            l2 = lmid\n\n    change = np.max(np.abs(xnew - x))\n    return rho, change\n</code></pre> <pre><code>@jax.jit\ndef strain_energy(eps, rho):\n    rho = rho.reshape(N, N)\n    eps = eps.reshape(ndim, ndim, N, N)\n\n    E = (\n        elastic_modulus[\"min\"]\n        + (elastic_modulus[\"max\"] - elastic_modulus[\"min\"]) * (rho + 0.01) ** penalty\n    )\n    \u03bd = jnp.ones_like(E) * poisson_modulus\n\n    \u03bc0 = E / (2 * (1 + \u03bd))\n\n    \u03bb0 = \u03bd * E / ((1 + \u03bd) * (1 - 2 * \u03bd))\n    \u03bb0 = 2*\u03bc0*\u03bb0/(\u03bb0 + 2*\u03bc0) # for plane stress\n\n\n    eps_sym = 0.5 * (eps + tensor.trans2(eps))\n    energy = 0.5 * jnp.multiply(\u03bb0, tensor.trace2(eps_sym) ** 2) + jnp.multiply(\n        \u03bc0, tensor.trace2(tensor.dot22(eps_sym, eps_sym))\n    )\n    return energy.sum()\n\n\nsigma = jax.jit(jax.jacrev(strain_energy, argnums=0))\n</code></pre> <pre><code># functions for the projection 'G', and the product 'G : K : eps'\n@jax.jit\ndef G(A2):\n    return jnp.real(ifft(tensor.ddot42(Ghat4_2, fft(A2)))).reshape(-1)\n\n\n@jax.jit\ndef G_K_deps(depsm, additionals):\n    depsm = depsm.reshape(ndim, ndim, N, N)\n    return G(sigma(depsm, additionals))\n</code></pre> <pre><code>@jax.jit\ndef scan_conjugate_gradient(state, n):\n    x, b, F, Fn, additional, r, p, rsold, iiter, cg_tol = state\n    x, b, additional, r, p, rsold = jax.device_put((x, b, additional, r, p, rsold))\n\n    error = jnp.sqrt(rsold) \n    jax.debug.print('CG residual = {}', error)\n\n    def true_fun(state):\n        x, b, F, Fn, additional, r, p, rsold, iiter, cg_tol =  state\n\n        Ap = G_K_deps(p, additional) \n        alpha = rsold / jnp.vdot(p, Ap)\n        x = x + jnp.dot(alpha, p)\n        r = r - jnp.dot(alpha, Ap)\n        rsnew = jnp.vdot(r, r) \n        p = r + (rsnew/rsold)*p\n        rsold = rsnew\n        iiter = iiter + 1\n        return (x, b, F, Fn, additional, r, p, rsold, iiter, cg_tol)\n\n    def false_fun(state):\n        return state\n\n    return jax.lax.cond(error &gt; cg_tol, true_fun, false_fun, state), n\n\n@jax.jit\ndef scan_newton_raphson(state, n):\n    #jax.debug.print('NR loop')\n    dF, b, F, Fn, additional, r, p, rsold, iiter, cg_tol = state\n\n\n\n    error = jnp.linalg.norm(dF)/Fn\n\n    #jax.debug.print('NR residual={}', error)\n\n    def true_fun(state):\n        dF, b, F, Fn, additional, r, p, rsold, iiter, cg_tol = state\n\n        x = jnp.zeros_like(b)\n        r = b - G_K_deps(x, additional)\n        p = r\n        rsold = jnp.vdot(r, r) \n\n        state = (x, b, F, Fn, additional, r, p, rsold, iiter, cg_tol)\n\n        state, xs = jax.lax.scan(scan_conjugate_gradient, \n                               init=state, \n                               xs=jnp.arange(0, 20))\n\n        dF, b, F, Fn, additional, r, p, rsold, iiter, cg_tol = state\n\n        dF     = dF.reshape(ndim,ndim,N,N)\n        F      = jax.lax.add(F, dF)         # update DOFs (array -&gt; tensor.grid)\n        b      = -G_K_deps(F, additional)        # compute residual\n\n        return (dF.reshape(-1), b, F, Fn, additional, r, p, rsold, iiter, cg_tol)\n\n    def false_fun(state):\n        return state\n\n    return jax.lax.cond(error &gt; 1e-8, true_fun, false_fun, state), n\n</code></pre> <pre><code>@jax.jit\ndef local_constitutive_update(macro_strain, rho):\n    eps = jnp.zeros([ndim, ndim, N, N])\n\n    deps = jnp.zeros([ndim, ndim, N, N])\n    deps = deps.at[0, 0].set(macro_strain[0])\n    deps = deps.at[1, 1].set(macro_strain[1])\n    deps = deps.at[0, 1].set(macro_strain[2] / 2.0)\n    deps = deps.at[1, 0].set(macro_strain[2] / 2.0)\n\n    # initial residual: distribute \"DE\" over grid using \"K4\"\n    b = -G_K_deps(deps, rho)\n    eps = jax.lax.add(eps, deps)\n    En = jnp.linalg.norm(eps)\n\n    # passing parameters for conjugate gradient\n    deps     = deps.reshape(-1)\n    r        = jnp.zeros_like(b)\n    p        = jnp.zeros_like(b) \n    rsold    = 0.\n    iiter    = 0.\n    cg_tol   = 1e-8\n\n    state    = (deps, b, eps, En, rho,  r, p, rsold, iiter, cg_tol)\n\n\n    #state = (deps, b, eps, En, rho)\n    state = jax.device_put(state)\n\n    final_state, xs = jax.lax.scan(\n        scan_newton_raphson, init=state, xs=jnp.arange(0, 20)\n    )\n\n    sig = sigma(final_state[2], rho)\n\n    # get the macro stress\n    macro_sigma = jnp.array([jnp.sum(sig.at[0, 0].get()*dx*dy), \n                             jnp.sum(sig.at[1, 1].get()*dx*dy), \n                             0.5*(jnp.sum(sig.at[1, 0].get()*dx*dy) + jnp.sum(sig.at[0, 1].get()*dx*dy))])\n    macro_sigma = macro_sigma/length**2\n\n    return macro_sigma\n\n\ntangent_operator = jax.jit(jax.jacfwd(\n    local_constitutive_update, argnums=0, has_aux=False\n))\n</code></pre> <pre><code>@jax.jit\ndef compute_objective(rho):\n    rho = rho.reshape(N, N)\n\n    macro_strain = jnp.array([1.0, 1.0, 1.])\n\n    Cmacro = tangent_operator(macro_strain, rho)\n    shear_modulus = Cmacro.at[2, 2].get()\n    bulk_modulus = (Cmacro.at[0, 0].get() + Cmacro.at[1, 1].get() + Cmacro.at[0, 1].get() + Cmacro.at[1, 0].get())/4 \n    poisson = (Cmacro.at[1, 0].get() + Cmacro.at[0, 1].get())/(Cmacro.at[0, 0].get() + Cmacro.at[1, 1].get())\n    J = -shear_modulus\n    #J = -poisson\n    #J = -bulk_modulus\n    '''eps = jnp.zeros([ndim, ndim, N, N])\n\n    deps = jnp.zeros([ndim, ndim, N, N])\n    deps = deps.at[0, 0].set(macro_strain[0])\n    deps = deps.at[1, 1].set(macro_strain[1])\n    deps = deps.at[0, 1].set(macro_strain[2] / 2.0)\n    deps = deps.at[1, 0].set(macro_strain[2] / 2.0)\n\n    # initial residual: distribute \"DE\" over grid using \"K4\"\n    b = -G_K_deps(deps, rho)\n    eps = jax.lax.add(eps, deps)\n    En = jnp.linalg.norm(eps)\n\n    # passing parameters for conjugate gradient\n    deps     = deps.reshape(-1)\n    #deps2    = jnp.zeros([ndim,ndim,N,N])\n    r        = jnp.zeros_like(b)\n    p        = jnp.zeros_like(b) \n    rsold    = 0.\n    iiter    = 0.\n    cg_tol   = 1e-10\n\n    state    = (deps, b, eps, En, rho,  r, p, rsold, iiter, cg_tol)\n\n\n    #state = (deps, b, eps, En, rho)\n    state = jax.device_put(state)\n\n    final_state, xs = jax.lax.scan(\n        scan_newton_raphson, init=state, xs=jnp.arange(0, 20)\n    )\n\n    # return macro_sigma\n    total_energy = 2*strain_energy(final_state[2], rho) #* length * length\n\n    J = -(total_energy)/(N*N)'''\n    jax.debug.print('J={}', J)\n\n    return J, J\n\n\nobjective_handle = jax.jit(jax.jacrev(compute_objective, has_aux=True))\n</code></pre> <pre><code>from jax import random\n\nkey = random.key(2)\n</code></pre> <pre><code>rho = get_initial_density(vf=vf)\n#rho=random.uniform(key, shape=(N, N))\nplt.figure(figsize=(2,2))\nplt.imshow(rho.reshape(N, N), cmap='Greys')\nplt.colorbar()\n</code></pre> <pre><code>&lt;matplotlib.colorbar.Colorbar at 0x1534fdba6350&gt;\n</code></pre> <p></p> <pre><code>compute_objective(rho)\n</code></pre> <pre><code>CG residual = 0.19215160248560498\nCG residual = 0.03345801064545514\nCG residual = 0.022725244309689748\nCG residual = 0.0021253379410087654\nCG residual = 0.001529706416414285\nCG residual = 0.0005935165225546164\nCG residual = 0.0002536036955032072\nCG residual = 0.0001960918878238921\nCG residual = 6.989287153370691e-05\nCG residual = 3.760377319774217e-05\nCG residual = 1.7913117236356724e-05\nCG residual = 4.357326472072343e-06\nCG residual = 3.587074687253273e-06\nCG residual = 1.0326111687990387e-06\nCG residual = 5.653929164246273e-07\nCG residual = 3.9625023224069544e-07\nCG residual = 1.208386419206797e-07\nCG residual = 7.332997495460921e-08\nCG residual = 2.9781698163273268e-08\nCG residual = 1.0437096819147349e-08\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nCG residual = 7.355661187859818e-09\nJ=-0.0008787942863382298\n</code></pre> <pre><code>(Array(-0.00087879, dtype=float64), Array(-0.00087879, dtype=float64))\n</code></pre> <pre><code>def optimize(maxIter=100):\n    rho = jnp.array(get_initial_density(vf))\n    change, loop = 10.0, 0\n\n    objective_values = []\n\n    while change &gt; 0.01 and loop &lt; maxIter:\n        loop += 1\n        dc, c = objective_handle(rho)\n\n        dv = jnp.ones((N * N))\n        dc, dv = apply_sensitivity_filter(ft, rho, dc, dv)\n\n        rho, change = oc(rho, dc, dv, ft, vf)\n        rho = jnp.array(rho)\n        status = \"iter {:d} ;  obj {:.2F} ; vol {:.2F}\".format(loop, c, jnp.mean(rho))\n        objective_values.append(c)\n        if loop % 20 == 0:\n            plt.figure(figsize=(2, 2))\n            plt.imshow(-rho.reshape((N, N)), cmap=\"gray\")\n            plt.title(status)\n            plt.show()\n\n        print(status, \"change {:.2F}\".format(change))\n    plt.imshow(-rho.reshape((N, N)), cmap=\"gray\")\n\n    return rho, objective_values\n</code></pre> <pre><code>rho, objective_values = optimize(50)\n</code></pre> <pre><code>J=-0.0008787942863382298\niter 1 ;  obj -0.00 ; vol 0.22 change 0.17\nJ=-0.0011264292428687427\niter 2 ;  obj -0.00 ; vol 0.23 change 0.20\nJ=-0.004658982855837879\niter 3 ;  obj -0.00 ; vol 0.28 change 0.20\nJ=-0.018540684887511497\niter 4 ;  obj -0.02 ; vol 0.30 change 0.20\nJ=-0.05008469804326539\niter 5 ;  obj -0.05 ; vol 0.30 change 0.20\nJ=-0.06264786596329028\niter 6 ;  obj -0.06 ; vol 0.30 change 0.20\nJ=-0.06676397728363354\niter 7 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.06930372871575895\niter 8 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07066291773856068\niter 9 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07173360640108709\niter 10 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07259355408918161\niter 11 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07303912658189629\niter 12 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.0734045811445772\niter 13 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07375986215516153\niter 14 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07410438109466494\niter 15 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07423194254441018\niter 16 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07431815311694735\niter 17 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07443191402165845\niter 18 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07458379112974596\niter 19 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.0747689063136045\n</code></pre> <p></p> <pre><code>iter 20 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.0748411880828251\niter 21 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07495386007683479\niter 22 ;  obj -0.07 ; vol 0.30 change 0.20\nJ=-0.07516157320342541\niter 23 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07517218876755548\niter 24 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07526691061178795\niter 25 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07514858970577003\niter 26 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.0752804842692488\niter 27 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07522608497798886\niter 28 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07517537991604127\niter 29 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07512172231358034\niter 30 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07520869691190356\niter 31 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07513338635393747\niter 32 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07521255448738662\niter 33 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07513287188385283\niter 34 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07520903409373031\niter 35 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07512744859586072\niter 36 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07520234757950907\niter 37 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07511983423536299\niter 38 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.0751942141342333\niter 39 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.075111041857415\n</code></pre> <p></p> <pre><code>iter 40 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07518533491640893\niter 41 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.0751017526410719\niter 42 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07517606349066527\niter 43 ;  obj -0.08 ; vol 0.30 change 0.19\nJ=-0.07523601320525647\niter 44 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07514937030673974\niter 45 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07522147202405528\niter 46 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07513685759584564\niter 47 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.0752102722182237\niter 48 ;  obj -0.08 ; vol 0.30 change 0.18\nJ=-0.07512612248099407\niter 49 ;  obj -0.08 ; vol 0.30 change 0.20\nJ=-0.07519981460437301\niter 50 ;  obj -0.08 ; vol 0.30 change 0.18\n</code></pre> <p></p> <pre><code>@jax.jit\ndef compute_local_stresses(macro_strain, rho):\n    eps = jnp.zeros([ndim, ndim, N, N])\n\n    deps = jnp.zeros([ndim, ndim, N, N])\n    deps = deps.at[0, 0].set(macro_strain[0])\n    deps = deps.at[1, 1].set(macro_strain[1])\n    deps = deps.at[0, 1].set(macro_strain[2] / 2.0)\n    deps = deps.at[1, 0].set(macro_strain[2] / 2.0)\n\n    # initial residual: distribute \"DE\" over grid using \"K4\"\n    b = -G_K_deps(deps, rho)\n    eps = jax.lax.add(eps, deps)\n    En = jnp.linalg.norm(eps)\n\n    # passing parameters for conjugate gradient\n    deps     = deps.reshape(-1)\n    r        = jnp.zeros_like(b)\n    p        = jnp.zeros_like(b) \n    rsold    = 0.\n    iiter    = 0.\n    cg_tol   = 1e-8\n\n    state    = (deps, b, eps, En, rho,  r, p, rsold, iiter, cg_tol)\n\n\n    #state = (deps, b, eps, En, rho)\n    state = jax.device_put(state)\n\n    final_state, xs = jax.lax.scan(\n        scan_newton_raphson, init=state, xs=jnp.arange(0, 20)\n    )\n\n    sig = sigma(final_state[2], rho)\n    return sig\n</code></pre> <pre><code>macro_strain = jnp.array([0.0, 0.0, 1.])\nstresses = compute_local_stresses(macro_strain, rho)\n</code></pre> <pre><code>CG residual = 17.3171631235316\nCG residual = 3.3523559935266927\nCG residual = 1.1616458628170108\nCG residual = 0.7071048239993468\nCG residual = 0.4102551775383743\nCG residual = 0.2815996234262036\nCG residual = 0.2356726717604784\nCG residual = 0.20847552404537817\nCG residual = 0.14748031924978694\nCG residual = 0.13790977301764834\nCG residual = 0.09555820905314172\nCG residual = 0.08580380458913597\nCG residual = 0.07853635788754036\nCG residual = 0.06432296058473638\nCG residual = 0.05913485120473688\nCG residual = 0.040752123349128845\nCG residual = 0.03699377371342441\nCG residual = 0.02670692886935146\nCG residual = 0.027017180958343504\nCG residual = 0.02443745369940184\nCG residual = 0.023329746504566765\nCG residual = 0.016573304106826843\nCG residual = 0.016184892287336883\nCG residual = 0.016088822061484966\nCG residual = 0.017997440874972737\nCG residual = 0.017282984372111804\nCG residual = 0.01905502625590263\nCG residual = 0.016459220779385345\nCG residual = 0.016508583930901048\nCG residual = 0.014467484344715635\nCG residual = 0.013386594877818446\nCG residual = 0.013700845919777218\nCG residual = 0.011583517483394583\nCG residual = 0.011744693022309101\nCG residual = 0.010080186219952549\nCG residual = 0.009701584865823306\nCG residual = 0.008994643712855552\nCG residual = 0.008800253517534978\nCG residual = 0.007646875811179997\nCG residual = 0.006484185116276834\nCG residual = 0.005860817964100012\nCG residual = 0.004174286232995927\nCG residual = 0.005093758789299297\nCG residual = 0.0053002689702317\nCG residual = 0.0052837844471449345\nCG residual = 0.005820025935261828\nCG residual = 0.00552954027112976\nCG residual = 0.005208076580234989\nCG residual = 0.0047350407194471575\nCG residual = 0.004887106805985015\nCG residual = 0.004503373824963124\nCG residual = 0.004880255617988739\nCG residual = 0.004680525727009202\nCG residual = 0.004485749559815816\nCG residual = 0.004253276149679063\nCG residual = 0.0039571295391523376\nCG residual = 0.003836603712235234\nCG residual = 0.0035790462532483184\nCG residual = 0.0034873863895135133\nCG residual = 0.003320809057920338\nCG residual = 0.003912563794162428\nCG residual = 0.0026247582183317126\nCG residual = 0.0027630427962338955\nCG residual = 0.0025747230559226178\nCG residual = 0.002763196806603714\nCG residual = 0.00262308073536214\nCG residual = 0.002624652294991569\nCG residual = 0.0023861569593529508\nCG residual = 0.0024361350962829403\nCG residual = 0.002373193938592661\nCG residual = 0.002199882606036559\nCG residual = 0.0022419186086384975\nCG residual = 0.001982864425098146\nCG residual = 0.0020245957301639867\nCG residual = 0.001939511996725496\nCG residual = 0.0020214845009849055\nCG residual = 0.001843134309512655\nCG residual = 0.0018076878838298343\nCG residual = 0.001656343733409944\nCG residual = 0.0013827758491892924\nCG residual = 0.0016999910130068322\nCG residual = 0.0012012381167926121\nCG residual = 0.0014319086268878662\nCG residual = 0.001458508753509088\nCG residual = 0.0014411298759282414\nCG residual = 0.0015198845204966727\nCG residual = 0.0013916944958517982\nCG residual = 0.0013484581619970764\nCG residual = 0.001280665783842277\nCG residual = 0.0013589322818447214\nCG residual = 0.0012733877977523789\nCG residual = 0.0013242187374433957\nCG residual = 0.0012483216347096704\nCG residual = 0.0011916374320381578\nCG residual = 0.0011821533574942337\nCG residual = 0.0011453204980780673\nCG residual = 0.0011385814674744177\nCG residual = 0.0010431353631482592\nCG residual = 0.0010345471586212644\nCG residual = 0.00099143642205721\nCG residual = 0.0013242561271742796\nCG residual = 0.0008761529533843223\nCG residual = 0.0009047756281230862\nCG residual = 0.0008396478782083797\nCG residual = 0.000893126253961209\nCG residual = 0.000844486038875927\nCG residual = 0.0008409548036641117\nCG residual = 0.0007781711772505435\nCG residual = 0.0008078992097945254\nCG residual = 0.0007852227432426971\nCG residual = 0.0007341343382748298\nCG residual = 0.0007359772701094299\nCG residual = 0.0006611917280978151\nCG residual = 0.000666928908215778\nCG residual = 0.0006422143700955842\nCG residual = 0.0006750922125672805\nCG residual = 0.0006165234410457885\nCG residual = 0.0006051100158403431\nCG residual = 0.0005629837562040691\nCG residual = 0.00047735375660067206\nCG residual = 0.0006146614779908176\nCG residual = 0.0004353468169308583\nCG residual = 0.0005090569323735469\nCG residual = 0.0005143048647526107\nCG residual = 0.0005073905028594093\nCG residual = 0.000529595559366938\nCG residual = 0.0004880674753225269\nCG residual = 0.00047488056191233015\nCG residual = 0.0004611244224391031\nCG residual = 0.0004818317522894509\nCG residual = 0.0004587557291018851\nCG residual = 0.00046901043395642934\nCG residual = 0.0004495980340600795\nCG residual = 0.0004246670057201449\nCG residual = 0.0004203103469075535\nCG residual = 0.0004125204480322556\nCG residual = 0.0004080005207794566\nCG residual = 0.00038079054792948964\nCG residual = 0.00037733972258368763\nCG residual = 0.000368696794062289\nCG residual = 0.0005001045677999607\nCG residual = 0.0003347807696288297\nCG residual = 0.0003370492298221746\nCG residual = 0.000314949293069689\nCG residual = 0.00033107794267468103\nCG residual = 0.0003131963135632822\nCG residual = 0.0003135183651311962\nCG residual = 0.0002908923540236293\nCG residual = 0.0003070507562171024\nCG residual = 0.0002932465064036322\nCG residual = 0.00027987843417074174\nCG residual = 0.0002740946832876985\nCG residual = 0.0002540623244786837\nCG residual = 0.0002500017425248802\nCG residual = 0.00024401534140624923\nCG residual = 0.00025346891786530803\nCG residual = 0.00023450155132028548\nCG residual = 0.00023060750298295961\nCG residual = 0.00021701052357318276\nCG residual = 0.0001861239316187628\nCG residual = 0.00024010270683084978\nCG residual = 0.0001733214400910371\nCG residual = 0.0001986399989039067\nCG residual = 0.0002004120694819331\nCG residual = 0.00019737219157703925\nCG residual = 0.00020384150208078506\nCG residual = 0.0001908891879966368\nCG residual = 0.00018432282495130266\nCG residual = 0.00018319317119313498\nCG residual = 0.00018695947572546377\nCG residual = 0.00018279512412779507\nCG residual = 0.0001820405669849969\nCG residual = 0.0001797469992941219\nCG residual = 0.0001659061334172743\nCG residual = 0.00016690318685593365\nCG residual = 0.0001619127207779465\nCG residual = 0.00016157245518748955\nCG residual = 0.00015157152864757862\nCG residual = 0.00015135991168386016\nCG residual = 0.0001494546096063298\nCG residual = 0.00020319166206001006\nCG residual = 0.00013796030200630453\nCG residual = 0.00013591418418031623\nCG residual = 0.00012829993601787005\nCG residual = 0.00013296377298961683\nCG residual = 0.0001263423435824343\nCG residual = 0.00012697498614478957\nCG residual = 0.00011821583384328617\nCG residual = 0.0001257733666051128\nCG residual = 0.00011896434903924902\nCG residual = 0.00011540538523555699\nCG residual = 0.0001109352117118499\nCG residual = 0.00010552966588050976\nCG residual = 0.000101567345970207\nCG residual = 0.00010114279851044416\nCG residual = 0.00010283031733003709\nCG residual = 9.708656268860285e-05\nCG residual = 9.459423532077804e-05\nCG residual = 9.093038253262321e-05\nCG residual = 7.746781774148341e-05\nCG residual = 0.00010151863115369138\nCG residual = 7.333290002955632e-05\nCG residual = 8.367594229585413e-05\nCG residual = 8.367709187693055e-05\nCG residual = 8.269101182784499e-05\nCG residual = 8.453335779456711e-05\nCG residual = 8.026269937573052e-05\nCG residual = 7.726393414323977e-05\nCG residual = 7.75415046222592e-05\nCG residual = 7.837276646379975e-05\nCG residual = 7.77403922531682e-05\nCG residual = 7.639307612968293e-05\nCG residual = 7.670701347322298e-05\nCG residual = 6.988840448664775e-05\nCG residual = 7.136591821716271e-05\nCG residual = 6.814841449197702e-05\nCG residual = 6.904241888876632e-05\nCG residual = 6.4356698669396e-05\nCG residual = 6.550750762243108e-05\nCG residual = 6.429024940431493e-05\nCG residual = 8.912550407150587e-05\nCG residual = 6.0044313372574956e-05\nCG residual = 5.895841481415709e-05\nCG residual = 5.554204496655328e-05\nCG residual = 5.730888715560122e-05\nCG residual = 5.445168743893874e-05\nCG residual = 5.497593323692572e-05\nCG residual = 5.15087270740867e-05\nCG residual = 5.4595432964234325e-05\nCG residual = 5.185664375532854e-05\nCG residual = 5.0371873880283054e-05\nCG residual = 4.84250274314246e-05\nCG residual = 4.6210833342718284e-05\nCG residual = 4.4561800310484505e-05\nCG residual = 4.436566734612203e-05\nCG residual = 4.4994801737922304e-05\nCG residual = 4.2608714201351064e-05\nCG residual = 4.166536674732157e-05\nCG residual = 4.040388221863648e-05\nCG residual = 3.442291524820599e-05\nCG residual = 4.581610263963938e-05\nCG residual = 3.2893394555227586e-05\nCG residual = 3.739502906467577e-05\nCG residual = 3.725819284923438e-05\nCG residual = 3.674330899997372e-05\nCG residual = 3.7494976141317974e-05\nCG residual = 3.57510606235682e-05\nCG residual = 3.4610241907870724e-05\nCG residual = 3.463123010990612e-05\nCG residual = 3.5087391398273104e-05\nCG residual = 3.490103797086214e-05\nCG residual = 3.42772414783961e-05\nCG residual = 3.449610509611387e-05\nCG residual = 3.153149787165923e-05\nCG residual = 3.218545050373541e-05\nCG residual = 3.069176420790451e-05\nCG residual = 3.117885019018204e-05\nCG residual = 2.9171035536488597e-05\nCG residual = 2.9903387577307127e-05\nCG residual = 2.9371122135397543e-05\nCG residual = 4.1264227166800124e-05\nCG residual = 2.763579878184482e-05\nCG residual = 2.7061700593708593e-05\nCG residual = 2.5460481956892496e-05\nCG residual = 2.6187676552547233e-05\nCG residual = 2.48732639436774e-05\nCG residual = 2.520517742576712e-05\nCG residual = 2.3739845443547118e-05\nCG residual = 2.5066865044198958e-05\nCG residual = 2.389300329918019e-05\nCG residual = 2.325511583885304e-05\nCG residual = 2.235949809701977e-05\nCG residual = 2.136253336316919e-05\nCG residual = 2.0691803802039644e-05\nCG residual = 2.056038647728718e-05\nCG residual = 2.085128376721415e-05\nCG residual = 1.9771630106994194e-05\nCG residual = 1.942450165663391e-05\nCG residual = 1.892012144654408e-05\nCG residual = 1.6170299894963534e-05\nCG residual = 2.1739846312991224e-05\nCG residual = 1.554491757693706e-05\nCG residual = 1.7601526890574464e-05\nCG residual = 1.751296286852572e-05\nCG residual = 1.722760935785701e-05\nCG residual = 1.756665247610719e-05\nCG residual = 1.6792924259948993e-05\nCG residual = 1.6338627834302686e-05\nCG residual = 1.629803124064292e-05\nCG residual = 1.6545774941426115e-05\nCG residual = 1.6506149637581854e-05\nCG residual = 1.6205593272798843e-05\nCG residual = 1.63289130731022e-05\nCG residual = 1.4990296026560477e-05\nCG residual = 1.5281001601152565e-05\nCG residual = 1.4573190376624717e-05\nCG residual = 1.4830275858301117e-05\nCG residual = 1.3936051533350978e-05\nCG residual = 1.4336313503171944e-05\nCG residual = 1.4122880925138582e-05\nCG residual = 2.0018613393023773e-05\nCG residual = 1.3360182785410979e-05\nCG residual = 1.3044127068083456e-05\nCG residual = 1.2270487339166332e-05\nCG residual = 1.2586914467441254e-05\nCG residual = 1.1952008377729927e-05\nCG residual = 1.214400819956046e-05\nCG residual = 1.1486825006943525e-05\nCG residual = 1.2091664090060122e-05\nCG residual = 1.1554224281180159e-05\nCG residual = 1.1274305646448105e-05\nCG residual = 1.0836806400445963e-05\nCG residual = 1.0362786346889398e-05\nCG residual = 1.0081639835453661e-05\nCG residual = 1.0000731569805639e-05\nCG residual = 1.014593739521643e-05\nCG residual = 9.63467188260427e-06\nCG residual = 9.505502145431367e-06\nCG residual = 9.281270997354251e-06\nCG residual = 7.96520724256752e-06\nCG residual = 1.0780422161904852e-05\nCG residual = 7.689119682001772e-06\nCG residual = 8.673153683008412e-06\nCG residual = 8.62765175979466e-06\nCG residual = 8.467205042087124e-06\nCG residual = 8.62969677384413e-06\nCG residual = 8.264447598598213e-06\nCG residual = 8.07361046362547e-06\nCG residual = 8.032554736213193e-06\nCG residual = 8.167012137628476e-06\nCG residual = 8.170736135670207e-06\nCG residual = 8.019484120342883e-06\nCG residual = 8.08720998807746e-06\nCG residual = 7.4552079089680414e-06\nCG residual = 7.590338942395897e-06\nCG residual = 7.242115641034714e-06\nCG residual = 7.381865111901182e-06\nCG residual = 6.965372715804866e-06\nCG residual = 7.178115534180111e-06\nCG residual = 7.0974185481948e-06\nCG residual = 1.0121886977367916e-05\nCG residual = 6.741856659055299e-06\nCG residual = 6.563404800125279e-06\nCG residual = 6.177779777555416e-06\nCG residual = 6.321977443518438e-06\nCG residual = 6.002363157775516e-06\nCG residual = 6.110123287111571e-06\nCG residual = 5.800309381201743e-06\nCG residual = 6.089829113128733e-06\nCG residual = 5.8309873345682614e-06\nCG residual = 5.703292999427135e-06\nCG residual = 5.480417626101292e-06\nCG residual = 5.243256496505441e-06\nCG residual = 5.121971005624008e-06\nCG residual = 5.073206061342765e-06\nCG residual = 5.149917595871885e-06\nCG residual = 4.897398955324102e-06\nCG residual = 4.8499989794852575e-06\nCG residual = 4.741176992332272e-06\nCG residual = 4.086629415571959e-06\nCG residual = 5.555683077483027e-06\nCG residual = 3.956924507978842e-06\nCG residual = 4.447514952854448e-06\nCG residual = 4.42652948325624e-06\nCG residual = 4.334708569199043e-06\nCG residual = 4.416854981130802e-06\nCG residual = 4.234956335248105e-06\nCG residual = 4.151378661609985e-06\nCG residual = 4.120676769884227e-06\nCG residual = 4.195301856336743e-06\nCG residual = 4.207394388584518e-06\nCG residual = 4.128914941146097e-06\nCG residual = 4.165413909667022e-06\nCG residual = 3.854617090376713e-06\nCG residual = 3.919639383857708e-06\nCG residual = 3.742146259881563e-06\nCG residual = 3.81964809526914e-06\nCG residual = 3.617719505850707e-06\nCG residual = 3.7305932650021938e-06\nCG residual = 3.7028202351601207e-06\nCG residual = 5.30278128803775e-06\nCG residual = 3.5286761730824727e-06\nCG residual = 3.4258546803934477e-06\nCG residual = 3.2281147757093668e-06\nCG residual = 3.296249073512347e-06\nCG residual = 3.129764870152408e-06\nCG residual = 3.1898141486023506e-06\nCG residual = 3.0376405293981448e-06\nCG residual = 3.181803997402644e-06\nCG residual = 3.0520600656233835e-06\nCG residual = 2.991131206979761e-06\nCG residual = 2.873766005292978e-06\nCG residual = 2.7495413185053422e-06\nCG residual = 2.6959406737558447e-06\nCG residual = 2.666275475534144e-06\nCG residual = 2.708416586926194e-06\nCG residual = 2.5786304241215374e-06\nCG residual = 2.562265708622603e-06\nCG residual = 2.505420607144204e-06\nCG residual = 2.168589808696337e-06\n</code></pre> <pre><code>import matplotlib.gridspec as gridspec\nfrom matplotlib import ticker\n</code></pre> <pre><code>fig = plt.figure(\n    figsize=set_size(width=\"two-column\", fraction=0.975, height_ratio=0.3),\n    constrained_layout=False,\n    dpi=200,\n)\ngs1 = gridspec.GridSpec(1, 2, figure=fig,  left=0.01, right=0.55, top=0.98, bottom=0.00)\ngs2.update(wspace=0.1) # set the spacing between axes. \n\nax = fig.add_subplot(gs1[:, 0])\nax.axes.get_xaxis().set_visible(False)\nax.axes.get_yaxis().set_visible(False)\nax = fig.add_subplot(gs1[:, 1])\nax.axes.get_xaxis().set_visible(False)\nax.axes.get_yaxis().set_visible(False)\n\ngs2 = gridspec.GridSpec(2, 2, figure=fig, height_ratios=[1, 0.5], left=0.65, right=0.98, top=0.99)\ngs2.update(hspace=0.1, wspace=0.01) # set the spacing between axes. \n\n\nax = fig.add_subplot(gs2[0, 0])\nax.imshow(rho.reshape((N, N)), cmap=\"Greys\")\nax.axes.get_xaxis().set_visible(False)\nax.axes.get_yaxis().set_visible(False)\n\n\nax = fig.add_subplot(gs2[0, 1])\ncs = ax.imshow(stresses.at[0, 0].get(), cmap=\"Spectral\")\nax.axes.get_xaxis().set_visible(False)\nax.axes.get_yaxis().set_visible(False)\naxins1 = ax.inset_axes([0.25, 0.5, 0.5, 0.05])\n\ncbar = fig.colorbar(cs, cax=axins1, pad=0.05, \n                      fraction=0.025, shrink=.5, orientation=\"horizontal\")\ntick_locator = ticker.MaxNLocator(nbins=2)\ncbar.locator = tick_locator\ncbar.update_ticks()\ncbar.set_label('$\\sigma_{xx}/E$', fontsize=10, labelpad=-32, y=0.85)\ncbar.ax.yaxis.set_offset_position('right')  \n\n\ngs3 = gridspec.GridSpec(1, 1, figure=fig, left=0.7, right=0.98, top=0.42,  bottom=0.15)\ngs3.update(hspace=0.1, wspace=0.01) # set the spacing between axes. \nax = fig.add_subplot(gs3[:, :])\nax.plot(-np.asarray(objective_values)/\u03bc, color='#de425b')\nax.axhline(y=np.max(-np.asarray(objective_values)/\u03bc), color='k', ls='dashed', zorder=-1)\nax.set_xlabel(r'$\\mathrm{\\#~iterations}$')\nax.set_ylabel(r'$\\overline{\\mu}/\\mu$')\nax.set_xlim(left=0, right=25)\n\nplt.savefig('../notebooks/figs/paper_to_shear_modulus.svg')\nplt.show()\n</code></pre> <p></p> <pre><code>\u03bc\n</code></pre> <pre><code>0.3846153846153846\n</code></pre> <pre><code>0.5 0.132\n0.3 0.075\n</code></pre> <pre><code>  Cell In[79], line 1\n    0.5 0.133\n        ^\nSyntaxError: invalid syntax\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"}]}